<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="剑指offer, moblog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>剑指offer | moblog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">moblog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">moblog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">剑指offer</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%91%E6%8C%87offer/">
                                <span class="chip bg-color">剑指offer</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-03
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>coding coding coding <span id="more"></span> </p>
<h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;

        &#x2F;&#x2F;哈希表
        unordered_set&lt;int&gt; record;
        int res ;
        &#x2F;&#x2F;遍历数组
        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;
            &#x2F;&#x2F;如果找到重复数字，将数字保存并退出循环
            if(record.count(nums[i]))&#123;           
                res &#x3D; nums[i];
                break;
            &#125;
            &#x2F;&#x2F;如果没有找到，将数字插入哈希表中
            else&#123;
                record.insert(nums[i]);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    string replaceSpace(string s) &#123;
        
        string res;
        &#x2F;&#x2F;遍历字符串
        for(int i&#x3D;0;i&lt;s.size();i++)&#123;
            &#x2F;&#x2F;如果遇到空格
            if(s[i]&#x3D;&#x3D;&#39; &#39;)&#123;
                res+&#x3D;&quot;%20&quot;;
            &#125;
            &#x2F;&#x2F;如果遇到非空格
            else&#123;
                res+&#x3D;s[i];
            &#125;
        &#125;
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,3,2]
输出：[2,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; reversePrint(ListNode* head) &#123;
        &#x2F;&#x2F;栈 先进后出
        stack&lt;int&gt; res;
        &#x2F;&#x2F;遍历链表，将元素入栈
        while(head!&#x3D;NULL)&#123;
            res.push(head-&gt;val);
            head&#x3D;head-&gt;next;
        &#125;
        vector&lt;int&gt; ret;
        &#x2F;&#x2F;出栈
        while(!res.empty())&#123;
            ret.push_back(res.top());
            res.pop();
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p> 示例 1：</p>
<p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p>
<p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class CQueue &#123;
private:
    &#x2F;&#x2F;输入栈
    stack&lt;int&gt; stackIn;
    &#x2F;&#x2F;输出栈
    stack&lt;int&gt; stackOut;

public:
    CQueue() &#123;

    &#125;  
    void appendTail(int value) &#123;
        stackIn.push(value);
    &#125; 
    int deleteHead() &#123;
        &#x2F;&#x2F;输入栈空 输出栈空
        if(stackIn.empty()&amp;&amp;stackOut.empty())  
           return -1;
        &#x2F;&#x2F;输入栈非空 输出栈空
        if(!stackIn.empty()&amp;&amp;stackOut.empty())&#123; 
            &#x2F;&#x2F;输入栈一直循环弹出栈顶元素,压入输出栈，直到输入栈空
            while(!stackIn.empty())
            &#123;
                stackOut.push(stackIn.top());
                stackIn.pop();
            &#125;
            &#x2F;&#x2F;返回输出栈栈顶元素，并弹出栈顶元素
            int out &#x3D; stackOut.top();
            stackOut.pop();
            return out;
        &#125;

        &#x2F;&#x2F;输入栈空 输出栈非空 &amp;&amp; 输入栈非空 输出栈非空
        &#x2F;&#x2F;输出栈非空直接返回输出栈栈顶元素，并弹出输出栈栈顶元素
        else&#123;
            int out &#x3D; stackOut.top();
            stackOut.pop();
            return out;
        &#125;
    &#125;
&#125;;

&#x2F;**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj &#x3D; new CQueue();
 * obj-&gt;appendTail(value);
 * int param_2 &#x3D; obj-&gt;deleteHead();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>动态规划</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int fib(int n) &#123;
        int zero &#x3D; 0;
        int one &#x3D;1;
        int sum &#x3D;0;
        if(n&#x3D;&#x3D;0) return 0;
        if(n&#x3D;&#x3D;1) return 1;
        &#x2F;&#x2F;注意取模运算
        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;
            sum &#x3D; one%(1000000007)+zero%(1000000007);
            zero &#x3D; one;
            one &#x3D; sum;
        &#125;
        return sum%(1000000007);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;

public:
    int numWays(int n) &#123;
    
    int zero &#x3D; 1;
    int one &#x3D; 1;
    int sum &#x3D;0;
    &#x2F;&#x2F;这里定义从零个台阶开始
    if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;1) return 1;
    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;
        sum &#x3D; zero+one;
        zero &#x3D;one%1000000007;
        one &#x3D; sum%1000000007;
    &#125;
    return sum%1000000007;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;

public:
    int numWays(int n) &#123;
    int one &#x3D; 1;
    int two &#x3D; 2;
    int sum &#x3D;0;
    if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;1) return 1;
    if(n&#x3D;&#x3D;2) return 2;
    for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;
        sum &#x3D;one+ two;
        one &#x3D; two %1000000007;
        two&#x3D; sum%1000000007;
    &#125;
    return sum%1000000007;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
<p>二分搜索</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minArray(vector&lt;int&gt;&amp; numbers) &#123;

        int n&#x3D;numbers.size();
        int left&#x3D;0;
        int right&#x3D;n-1;
        &#x2F;&#x2F;这里是对数组下标的定义的 [left,right]
        while(left&lt;right)&#123;

            &#x2F;&#x2F;mid
            int mid &#x3D; left+(right-left)&#x2F;2;

             &#x2F;&#x2F;mid右边比中间大，mid右边一定是有序数组
             &#x2F;&#x2F;最小值在mid的左边，
             &#x2F;&#x2F;这里不确定mid是否是最小,所以可以进入下一次循环
            if(numbers[right]&gt;numbers[mid])&#123;
                 right &#x3D; mid;
             &#125;
             &#x2F;&#x2F;mid右边比中间小，mid左边一定是有序数组
             &#x2F;&#x2F;最小子在mid的右边
             &#x2F;&#x2F;这里已经确定mid不是最小，所以不用进入下次循环
             else if(numbers[right]&lt;numbers[mid])&#123;
                 left &#x3D; mid+1;
             &#125;
             &#x2F;&#x2F;numbers[right]&#x3D;&#x3D;numbers[mid]
             &#x2F;&#x2F;[mid,right]之间的元素都相等
            
             else &#123;
                 &#x2F;&#x2F;将mid指针左移
                 right--;
             &#125;
        &#125;
        return numbers[left];
    &#125;
&#125;;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int hammingWeight(uint32_t n) &#123;
        int ans&#x3D;0;
        for(int i&#x3D;0;i&lt;32;i++)
        &#123;
             ans+&#x3D;(n&gt;&gt;i)&amp;1;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p>
<p>说明：</p>
<p>用返回一个整数列表来代替打印<br>n 为正整数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; printNumbers(int n) &#123;
        vector&lt;int&gt; res;
        &#x2F;&#x2F;10的n次方
        cout&lt;&lt;pow(10,n);
        for(int i&#x3D;1;i&lt;pow(10,n);i++)&#123;
             res.push_back(i);
        &#125;
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明：</p>
<p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* deleteNode(ListNode* head, int val) &#123;

        ListNode* phead1 &#x3D; head;&#x2F;&#x2F;保存头结点
        ListNode* phead2 &#x3D; head;
        ListNode* re&#x3D;NULL;&#x2F;&#x2F;找到删除的结点
        &#x2F;&#x2F;寻找结点
        while(head!&#x3D;NULL)&#123;
            if(head-&gt;val &#x3D;&#x3D;val)&#123;
                re &#x3D; head;
                break;
            &#125;
            head &#x3D; head-&gt;next;
        &#125;
        &#x2F;&#x2F;删除结点
        while(phead1!&#x3D;NULL)&#123;
            if(phead1-&gt;next&#x3D;&#x3D;re)&#123;
                phead1-&gt;next &#x3D; phead1-&gt;next-&gt;next;
            &#125;
            else&#123;
                phead1 &#x3D; phead1-&gt;next;
            &#125;
        &#125;
        &#x2F;&#x2F;如果是头结点
        if(re&#x3D;&#x3D;phead2) 
            return phead2-&gt;next;
        else 
            return phead2;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p>示例：</p>
<p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p>
<p>提示：</p>
<p>0 &lt;= nums.length &lt;= 50000<br>0 &lt;= nums[i] &lt;= 10000</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isEven(int n)&#123;
        return n%2&#x3D;&#x3D;0;
    &#125;
    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123;
        &#x2F;&#x2F;双指针
        int l&#x3D;0;
        int r&#x3D;nums.size()-1;

        while(l&lt;r)&#123;
            &#x2F;&#x2F;如果左指针指的是偶数，右指针指的是奇数
            &#x2F;&#x2F;交换两个指针对应的元素
             if(isEven(nums[l])&amp;&amp;!isEven(nums[r]))&#123;
                swap(nums[l],nums[r]);
                l++;
                r--;
            &#125;
            &#x2F;&#x2F;如果左指针是奇数 左指针右移
            if(!isEven(nums[l]))&#123;
                l++;
            &#125;
            &#x2F;&#x2F;如果右指针是偶数，右指针左移
            if(isEven(nums[r]))&#123;
                r--;
            &#125;                  
        &#125;
        return nums;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* getKthFromEnd(ListNode* head, int k) &#123;
        ListNode *record &#x3D; head;
        &#x2F;&#x2F;整数第k个结点 record
        for(int i&#x3D;0;i&lt;k;i++)&#123;
            record &#x3D; record-&gt;next;
        &#125;
        &#x2F;&#x2F;假设有共n个结点
        &#x2F;&#x2F;以record 开始的链表还有n-k个；
        &#x2F;&#x2F;head移动n-k个结点的位置就是倒数第k个结点的位置
        while(record!&#x3D;NULL)&#123;
            record &#x3D; record-&gt;next;
            head &#x3D; head-&gt;next;
        &#125;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        &#x2F;&#x2F;保存上一个结点的指针 因为最后一个结点指针指向为空，所以设置为空
        ListNode* perv&#x3D;NULL;
        &#x2F;&#x2F;保存当前结点
        ListNode* cur&#x3D;head;
        &#x2F;&#x2F;保存当前结点的下一个结点
        ListNode* nextp&#x3D;NULL;

        while(cur!&#x3D;NULL)&#123;
            &#x2F;&#x2F; 保存当前结点的下一个结点
            nextp &#x3D; cur-&gt;next;
            &#x2F;&#x2F;指针翻转
            cur-&gt;next &#x3D; perv;

            &#x2F;&#x2F;指针后移
            perv &#x3D; cur;
            cur &#x3D; nextp;         
        &#125;
        return perv;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 1000</p>
<p>注意利用链表有序</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;
        &#x2F;&#x2F;递归写法
        if(l1&#x3D;&#x3D;NULL)
            return l2;
        if(l2&#x3D;&#x3D;NULL)
            return l1;
        &#x2F;&#x2F;合并链表后的头指针
        ListNode* res&#x3D;NULL;
        if(l1-&gt;val &lt; l2-&gt;val)&#123;
            &#x2F;&#x2F;赋值为指针指向值较小的指针
            res &#x3D; l1;
            &#x2F;&#x2F;递归
            res-&gt;next &#x3D; mergeTwoLists(l1-&gt;next,l2);
        &#125;
        else&#123;
            res &#x3D; l2;
            res-&gt;next &#x3D; mergeTwoLists(l1,l2-&gt;next);         
        &#125;
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre>
<p>镜像输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* mirrorTree(TreeNode* root) &#123;

        if(root&#x3D;&#x3D;NULL)
            return NULL;
        &#x2F;&#x2F;左子树
        TreeNode* left &#x3D; mirrorTree(root-&gt;left);
        &#x2F;&#x2F;右子树
        TreeNode* right &#x3D; mirrorTree(root-&gt;right);
        &#x2F;&#x2F;左右子树交换位置
        root-&gt;right &#x3D; left;
        root-&gt;left &#x3D; right;

        return root;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre class="line-numbers language-none"><code class="language-none">    1
   &#x2F; \
  2   2
 &#x2F; \ &#x2F; \
3  4 4  3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>    1
   / \
  2   2
   \   \
    3    3 
</code></pre>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isSame(TreeNode* l,TreeNode* r)&#123;
        &#x2F;&#x2F;左右子树都为空
        if(l&#x3D;&#x3D;NULL&amp;&amp;r&#x3D;&#x3D;NULL)&#123;
            return true;
        &#125;
        &#x2F;&#x2F;左不空，右空
        if(l!&#x3D;NULL&amp;&amp;r&#x3D;&#x3D;NULL)&#123;
            return false;
        &#125;
        &#x2F;&#x2F;左空，右不空
        if(l&#x3D;&#x3D;NULL&amp;&amp;r!&#x3D;NULL)&#123;
            return false;
        &#125;
        &#x2F;&#x2F;左右都不为空
        return (l-&gt;val&#x3D;&#x3D;r-&gt;val)
        &amp;&amp;issame(l-&gt;left,r-&gt;right)
        &amp;&amp;isSame(l-&gt;right,r-&gt;left);
    &#125;
    bool isSymmetric(TreeNode* root) &#123;

        if(root&#x3D;&#x3D;NULL)
            return true;
        return isSame(root-&gt;left,root-&gt;right);     
        &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<p>限制：</p>
<p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    &#x2F;&#x2F;四个方向
    static constexpr int directions[4][2]&#x3D;&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        &#x2F;&#x2F;如果矩阵为空，则返回空数组
        if(matrix.size()&#x3D;&#x3D;0||matrix[0].size()&#x3D;&#x3D;0)&#123;
            return &#123;&#125;;
        &#125;
        &#x2F;&#x2F;行
        int rows &#x3D;  matrix.size();
        &#x2F;&#x2F;列
        int columns &#x3D; matrix[0].size();
        &#x2F;&#x2F;标记访问过的元素
        vector&lt;vector&lt;bool&gt;&gt; visited(rows,vector&lt;bool&gt;(columns));
        &#x2F;&#x2F;总的元素个数
        int total &#x3D; rows*columns;
        &#x2F;&#x2F;返回数组的大小
        vector&lt;int&gt; res(total);
        &#x2F;&#x2F;从矩阵左上角开始
        int row &#x3D; 0;
        int column &#x3D; 0;
        &#x2F;&#x2F;方向索引 从向右开始
        int directionIndex &#x3D; 0;


        &#x2F;&#x2F;遍历
        for(int i&#x3D;0;i&lt;total;i++)&#123;
            &#x2F;&#x2F;访问元素
            res[i] &#x3D; matrix[row][column];
            &#x2F;&#x2F;标记已经访问
            visited[row][column] &#x3D; true;

            &#x2F;&#x2F;尝试一直往一个方向走
            &#x2F;&#x2F;注意这里是预判，并没有更新坐标
            int nextrow &#x3D; row+directions[directionIndex][0];
            int nextcolumn &#x3D; column+directions[directionIndex][1];

            &#x2F;&#x2F;预判遇到边界 或者已经被访问过的元素
            if(nextrow&lt;0||nextrow&gt;&#x3D;rows||nextcolumn&lt;0||nextcolumn&gt;&#x3D;columns||visited[nextrow][nextcolumn])&#123;
                &#x2F;&#x2F;开始转向 这里采用加一取余 可以保证方向的循环
                directionIndex &#x3D; (directionIndex+1)%4;
            &#125;
            &#x2F;&#x2F;更新下一个坐标
            row+&#x3D; directions[directionIndex][0];
            column+&#x3D;directions[directionIndex][1];
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>示例:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MinStack minStack &#x3D; new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.min();   --&gt; 返回 -2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>提示：</p>
<p>各函数的调用总次数不超过 20000 次</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MinStack &#123;
    &#x2F;&#x2F;基本元素栈
    stack&lt;int&gt; x_stack;
    &#x2F;&#x2F;最小元素栈
    stack&lt;int&gt; min_stack;
public:
    &#x2F;** initialize your data structure here. *&#x2F;
    MinStack() &#123;
        &#x2F;&#x2F;初始化 最小元素栈 压入最大的int整数
        min_stack.push(INT_MAX);
    &#125;
    void push(int x) &#123;
        &#x2F;&#x2F;入栈
        x_stack.push(x);
        &#x2F;&#x2F;判断是否要改变最小栈栈顶元素，
        &#x2F;&#x2F;保证最小栈的栈顶是最小的元素
        &#x2F;&#x2F;注意这里两个栈的元素的个数是一样的
        min_stack.push(std::min(x,min_stack.top()));
    &#125;
    void pop() &#123;
        &#x2F;&#x2F;弹出基本栈栈顶元素
        x_stack.pop();
        &#x2F;&#x2F;这个时候最小栈也要弹出栈顶元素
        min_stack.pop();

    &#125;
    
    int top() &#123;
        return x_stack.top();
    &#125;
    
    int min() &#123;
        return min_stack.top();

    &#125;
&#125;;

&#x2F;**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj &#x3D; new MinStack();
 * obj-&gt;push(x);
 * obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;top();
 * int param_4 &#x3D; obj-&gt;min();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">  3
 &#x2F; \
9  20
  &#x2F;  \
 15   7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>返回其层次遍历结果：</p>
<pre class="line-numbers language-none"><code class="language-none">[
  [3],
  [9,20],
  [15,7]
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>提示：</p>
<p>节点总数 &lt;= 1000</p>
<p>基本思路就是树的层序遍历 需要用到的数据结构就是队列</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;

        vector&lt;vector&lt;int&gt;&gt; res;

        queue&lt;TreeNode*&gt; q;&#x2F;&#x2F;队列，先进先出
        if(root!&#x3D;NULL) q.push(root);
        while(!q.empty())&#123;
            int n &#x3D; q.size();&#x2F;&#x2F;每一层循环次数；
            vector&lt;int&gt; leval;
            for(int i&#x3D;0;i&lt;n;i++)&#123;
                TreeNode* cur &#x3D; q.front();&#x2F;&#x2F;队列头
                q.pop();
                leval.push_back(cur-&gt;val);
                if(cur-&gt;left!&#x3D;NULL) q.push(cur-&gt;left);
                if(cur-&gt;right!&#x3D;NULL) q.push(cur-&gt;right);
            &#125;
            res.push_back(leval);
        &#125;
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p>
<p>限制：</p>
<p>1 &lt;= 数组长度 &lt;= 50000</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(),nums.end());
        return nums[nums.size()&#x2F;2];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>示例 1：</p>
<p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p>
<p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p>
<p>限制：</p>
<p>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p>
<p>典型top K 需要用到的数据结构是优先队列(最大堆)</p>
<p>一般 最小K 用最大堆 ，最大K用最小堆</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; knums; &#x2F;&#x2F;默认是最大堆，这样就是最小堆<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;

    &#x2F;&#x2F;优先队列默认是最大堆
    priority_queue&lt;int&gt; knums;&#x2F;&#x2F;最大堆

    vector&lt;int&gt;res;

    if(k&#x3D;&#x3D;0||arr.size()&#x3D;&#x3D;0) return res;

    &#x2F;&#x2F;先将k个元素压入最大堆中 堆顶元素的值最大
    for(int i&#x3D;0;i&lt;k;i++)&#123;
        knums.push(arr[i]);
    &#125;
    &#x2F;&#x2F;接着遍历剩下的数，如果小于栈顶元素，则压入堆中
    for(int i&#x3D;k;i&lt;arr.size();i++)&#123;
        if(arr[i]&lt;knums.top())&#123;
            knums.pop();
            knums.push(arr[i]);
        &#125;
    &#125;
    &#x2F;&#x2F;最后弹出堆中元素到返回数组中
    while(!knums.empty())&#123;
        res.push_back(knums.top());
        knums.pop();
    &#125;
    return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p>示例1:</p>
<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>提示：</p>
<p>1 &lt;= arr.length &lt;= 10^5<br>-100 &lt;= arr[i] &lt;= 100</p>
<p>动态规划</p>
<p>思路</p>
<p>有点类似与最长上升子序列</p>
<p>定义 f(i)代表以第 i个数结尾的「连续子数组的最大和」</p>
<p>结果就是max(f(i))</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;

        int n &#x3D; nums.size();
        int pre&#x3D;0;
        int maxv&#x3D;nums[0];
        for(int i&#x3D;0;i&lt;n;i++)&#123;
            &#x2F;&#x2F;如果加上当前元素，是否会更小
            pre &#x3D; max(pre+nums[i],nums[i]);
            
            maxv &#x3D; max(maxv,pre);
        &#125;
        return maxv;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>相交的人总会相遇</p>
<p>太浪漫了 两个结点不断的去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇❤</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        &#x2F;&#x2F;如果两个结点中有一个为空则返回空指针
        if(headA&#x3D;&#x3D;NULL||headB&#x3D;&#x3D;NULL)
            return NULL;
        
        ListNode* pa &#x3D; headA;
        ListNode* pb &#x3D; headB;
        while(pa!&#x3D;pb)&#123;
            &#x2F;&#x2F;如果到了链表尾，则接到对方的头部
            &#x2F;&#x2F;本质是将两条链表分别接到对方后面，然后遍历
            pa&#x3D;pa&#x3D;&#x3D;NULL?headB:pa-&gt;next;
            pb&#x3D;pb&#x3D;&#x3D;NULL?headA:pb-&gt;next;
        &#125;
        return pa;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><p>统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p>
<p>提示：</p>
<p>0 &lt;= nums.length &lt;= 105<br>-109 &lt;= nums[i] &lt;= 109<br>nums 是一个非递减数组<br>-109 &lt;= target &lt;= 109</p>
<p>在排序数组中搜索数组，就是暗示往二分搜索方向</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
   int binarySearch(vector&lt;int&gt;&amp; nums,int target,bool lower)&#123;
        &#x2F;&#x2F;目的是找到左右边界
        &#x2F;&#x2F;这里定义lower是为了复用代码
        &#x2F;&#x2F;在这里我们定义的边界是 [left,right] 左闭右闭
        int left &#x3D; 0, right &#x3D; nums.size()-1;
        
        int index &#x3D; nums.size();
        &#x2F;&#x2F;开始二分搜索
        &#x2F;&#x2F;这里为什么要等号，根据我们的定义，这是数组中还有一个元素
        while(left&lt;&#x3D;right)&#123;

            &#x2F;&#x2F;中间位置
            int mid &#x3D; left+(right-left)&#x2F;2;

            if(nums[mid]&gt;target||lower&amp;&amp;nums[mid]&gt;&#x3D;target)&#123;
                right &#x3D; mid -1;
                index &#x3D; mid;
            &#125;else&#123;
                &#x2F;&#x2F;(nums[mid]&lt;target
                left &#x3D; mid +1;
            &#125;
        &#125;
        return index;
    &#125;
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        
       int n &#x3D; nums.size();
        int lId &#x3D; binarySearch(nums,target,true);
        &#x2F;&#x2F;这里返回的是右边界的下一个位置，所以要减一
        int rId &#x3D; binarySearch(nums,target,false)-1;
        if(lId&lt;&#x3D;rId&amp;&amp;rId&lt;n&amp;&amp;nums[lId]&#x3D;&#x3D;target&amp;&amp;nums[rId]&#x3D;&#x3D;target)&#123;
            return  rId-lId+1;
        &#125;
        return 0;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例 1:</p>
<p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p>
<p>限制：</p>
<p>1 &lt;= 数组长度 &lt;= 10000</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    &#x2F;&#x2F;二分法
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;

        int l&#x3D;0;
        int r&#x3D;nums.size()-1;
        while(l&lt;&#x3D;r)&#123;
            int m &#x3D; (r-l)&#x2F;2+l;
            &#x2F;&#x2F;左边都是有序的
            if(nums[m]&#x3D;&#x3D;m)
                 l&#x3D;m+1;
            else 
            &#x2F;&#x2F;右边都是有序的
                r&#x3D;m-1;
        &#125;
        return l;



    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。</p>
<p>示例 1:</p>
<p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 4<br>示例 2:</p>
<p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>输出: 4</p>
<p>限制：</p>
<p>1 ≤ k ≤ 二叉搜索树元素个数</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;中序遍历
private: 
    int re&#x3D;0;
public:
    void Inorder(TreeNode* root,int&amp; k)&#123;
        if(!root)
            return;
        &#x2F;&#x2F;注意这里虽然是递归的中序遍历
        &#x2F;&#x2F;但是为了保证降序，所以先访问右子树
        if(root-&gt;right) Inorder(root-&gt;right,k);
             k--;
        if(!k) &#123;
            re &#x3D; root-&gt;val;
            return;
        &#125;
        if(root-&gt;left) Inorder(root-&gt;left,k);
    &#125;
    int kthLargest(TreeNode* root, int k) &#123;

        TreeNode* t &#x3D; root;
    
        Inorder(t,k);
        return re;   
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 
</code></pre>
<p>递归写法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    &#x2F;&#x2F;求一个二叉树的高度
    int height(TreeNode* root)&#123;
        if(root&#x3D;&#x3D;NULL)
            return 0;
        return max(height(root-&gt;left),height(root-&gt;right))+1;
    &#125;

    bool isBalanced(TreeNode* root) &#123;
        if(root&#x3D;&#x3D;NULL)
            return true;
            &#x2F;&#x2F;左右子树高度差小于一
        return abs(height(root-&gt;left)-height(root-&gt;right))&lt;&#x3D;1
            &#x2F;&#x2F;左右子树也是平衡树
        &amp;&amp;isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</code></pre>
<p>返回 false 。</p>
<p>这里用到求二叉树的高度的算法</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int height(TreeNode* root)&#123;
        if(root&#x3D;&#x3D;NULL)
            return 0;
        return max(height(root-&gt;left),height(root-&gt;right))+1;
    &#125;
    bool isBalanced(TreeNode* root) &#123;

        if(root&#x3D;&#x3D;NULL)
            return true;
        return abs(height(root-&gt;left)-height(root-&gt;right))&lt;&#x3D;1&amp;&amp;isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h4><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br>示例 2：</p>
<p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p>
<p>有序数组往往是和二分搜索联系在一起</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;int&gt; rev;
        int n &#x3D; nums.size();
        for(int i&#x3D;0;i&lt;n;i++)&#123;
            rev.clear();
            int t &#x3D; target-nums[i];
            rev.push_back(nums[i]);
            int l &#x3D; 0;
            int r &#x3D; n-1;
            while(l&lt;&#x3D;r)&#123;
                int mid &#x3D; (r-l)&#x2F;2+l;
                if(nums[mid]&#x3D;&#x3D;t&amp;&amp;mid!&#x3D;i)&#123;
                    rev.push_back(nums[mid]);
                    return rev;
                &#125;
                if(nums[mid]&gt;t)&#123;
                    r &#x3D; mid-1;
                &#125;
                else&#123;
                    l &#x3D; mid+1;
                &#125;
            &#125;
        &#125;
        return &#123;&#125;;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<p>输入：target = 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p>
<p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p>限制：</p>
<p>1 &lt;= target &lt;= 10^5</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;

        vector&lt;vector&lt;int&gt;&gt; re;

        &#x2F;&#x2F;双指针
        int l &#x3D; 1,r&#x3D;l+1;

        while(l&lt;r)&#123;
            &#x2F;&#x2F;等差数列求和
            int sum &#x3D; (l+r)*(r-l+1)&#x2F;2;
            &#x2F;&#x2F;如果满足目标，则将该等差数列写入返回数组中
            if(sum &#x3D;&#x3D; target)&#123;
                vector&lt;int&gt; temp;
                for(int i&#x3D;l;i&lt;&#x3D;r;i++)&#123;
                    temp.push_back(i);
                &#125;
                re.push_back(temp);
                &#x2F;&#x2F;左指针右移
                l++;
            &#125;
            else if(sum&lt;target)&#123;
                &#x2F;&#x2F;说明左指针开始的序列还比较小
                &#x2F;&#x2F;右指针右移
                r++;
            &#125; 
        return re;

    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>说明：</p>
<p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    string reverseWords(string s) &#123;
        if(s.empty())
            return s;
        string res &#x3D; &quot;&quot;;
        &#x2F;&#x2F;寻找单词的左边界
        int l &#x3D; s.size()-1;
        while(l&gt;&#x3D;0)&#123;
            while(l&gt;&#x3D;0&amp;&amp;s[l]&#x3D;&#x3D;&#39; &#39;) &#123;
                --l;
            &#125;
            &#x2F;&#x2F;跳出循环说明已经找到了单词的右边界
            &#x2F;&#x2F;将右边界记录下来继续找左边界
            int r &#x3D; l;
            while(l&gt;&#x3D;0&amp;&amp;s[l]!&#x3D;&#39; &#39;)&#123;
                --l;
            &#125;
            &#x2F;&#x2F;跳出循环说明已经找到了单词的左边界
            
          	&#x2F;&#x2F;避免将s前面的空格也加上
            if(r&gt;l)&#123;
                res+&#x3D;s.substr(l+1,r-l);
                res+&#x3D;&quot; &quot;;
            &#125;
        &#125;
        &#x2F;&#x2F;去掉后面加上的空格
        return res.substr(0,res.size()-1);


    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”<br>示例 2：</p>
<p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    string reverseLeftWords(string s, int n) &#123;

        int length &#x3D; s.size();
        string res &#x3D; &quot;&quot;;
        &#x2F;&#x2F;先加上后面的子串
        res+&#x3D;s.substr(n,length-1);
        &#x2F;&#x2F;再加上前面的子串
        res+&#x3D;s.substr(0,n);
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>注意：而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isStraight(vector&lt;int&gt;&amp; nums) &#123;
        &#x2F;&#x2F;排序，使零元素排在前面
        sort(nums.begin(),nums.end());
        &#x2F;&#x2F; 统计零，因为零可以当癞子
        int zero &#x3D;0;
        for(int i&#x3D;0;i&lt;4;i++)&#123;
            if(nums[i]&#x3D;&#x3D;0) &#123;
                 zero++;
            &#125;       
            else &#123;
               &#x2F;&#x2F;要将数组设置大一些 i+1&gt;4不安全
                if(nums[i]&#x3D;&#x3D;nums[i+1]) 
                    return false;
            &#125;        
        &#125;
        &#x2F;&#x2F;这里就是说，如果除了零外的最大到最小元素之差
        &#x2F;&#x2F;如果不大于癞子的个数，就可以组成顺子
        &#x2F;&#x2F;这里zero的第一个非零元素的下标
        return nums[4]-nums[zero]&lt;5;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: n &#x3D; 5, m &#x3D; 3
输出: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: n &#x3D; 10, m &#x3D; 17
输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int lastRemaining(int n, int m) &#123;
        int x &#x3D; 0;
        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;
            x &#x3D; (x + m) % i;
        &#125;
        return x;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p>示例:</p>
<p>输入: a = 1, b = 1<br>输出: 2</p>
<p>提示：</p>
<p>a, b 均可能是负数或 0<br>结果不会溢出 32 位整数</p>
<p>计算机组成原理的加法器</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int add(int a, int b) &#123;
        while (b) &#123;
            int carry &#x3D; a &amp; b; &#x2F;&#x2F; 计算 进位
            a &#x3D; a ^ b; &#x2F;&#x2F; 计算 本位
            b &#x3D; (unsigned)carry &lt;&lt; 1;
        &#125;
        return a;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>注意利用二叉搜索树这个隐含条件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;

        if(root &#x3D;&#x3D; NULL)
            return NULL;
        if(p-&gt;val&gt;root-&gt;val&amp;&amp;q-&gt;val&gt;root-&gt;val)&#123;
            return lowestCommonAncestor(root-&gt;right,p,q);
        &#125;
        if(p-&gt;val&lt;root-&gt;val&amp;&amp;q-&gt;val&lt;root-&gt;val)&#123;
            return lowestCommonAncestor(root-&gt;left,p,q);
        &#125;
        return root;
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(root &#x3D;&#x3D; NULL||p&#x3D;&#x3D;root||q&#x3D;&#x3D;root)&#123;
            return root;
        &#125;
        TreeNode* l &#x3D; lowestCommonAncestor(root-&gt;left,p,q);
        TreeNode* r &#x3D; lowestCommonAncestor(root-&gt;right,p,q);
      
       if (l!&#x3D; NULL &amp;&amp; r !&#x3D; NULL) &#123;
            &#x2F;&#x2F; p q 一个在左，一个在右
            return root;
        &#125;
        if (l !&#x3D; NULL) &#123;
            &#x2F;&#x2F; p q 都在左子树
            return l;
        &#125;
        if (r !&#x3D; NULL) &#123;
            &#x2F;&#x2F; p q 都在右子树
            return r;
        &#125;
        return NULL;
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="面试题50-第一个只出现一次的字符"><a href="#面试题50-第一个只出现一次的字符" class="headerlink" title="面试题50. 第一个只出现一次的字符"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">面试题50. 第一个只出现一次的字符</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从矩阵 <em>matrix</em> 的右上角 (0, n-1)进行搜索</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;    
        &#x2F;&#x2F;row行 column 列

        int row &#x3D; matrix.size();
        if(row&#x3D;&#x3D;0) return false;
        int column &#x3D; matrix[0].size();
   
        &#x2F;&#x2F;关键一步 从矩阵右上角开始
        int i&#x3D;0;
        int j&#x3D;column-1;

        while(i&lt;row&amp;&amp;j&gt;&#x3D;0)&#123;
            if(matrix[i][j]&#x3D;&#x3D;target)&#123;
                return true;
            &#125;
            else&#123;
                if(matrix[i][j]&gt;target)&#123;
                    j--;&#x2F;&#x2F;减一列 因为当前行后面的列肯定大
                &#125;
                else&#123;&#x2F;&#x2F;matrix[i][j]&gt;target
                    i++;&#x2F;&#x2F;加一行 因为当前列的后面行可定大
                &#125;
            &#125;
        &#125;
        return false;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;

private:
    &#x2F;&#x2F;构建哈希表，用来快速访问中序遍历中根节点的索引值
    unordered_map&lt;int,int&gt; inorderMap;
public:
    TreeNode* build(vector&lt;int&gt;&amp; preorder,vector&lt;int&gt;&amp; inorder, int pre_l,int pre_r,int in_l,int in_r )&#123;

        &#x2F;&#x2F;递归终止条件
        if(pre_l&gt;pre_r)&#123;
            return nullptr;
        &#125;

        &#x2F;&#x2F;根节点的值
        &#x2F;&#x2F;先序遍历中根节点的值比较容易确定
        int rootValue &#x3D; preorder[pre_l];
        TreeNode* root &#x3D; new TreeNode(rootValue);

       
        &#x2F;&#x2F;中序遍历中根节点的位置
        int rootIndex &#x3D; inorderMap[rootValue];

        &#x2F;&#x2F;确定左子树和右子树长度
        &#x2F;&#x2F;左子树的节点数
        int size_subtree_l &#x3D; rootIndex - in_l;
        int size_subtree_r &#x3D; in_r - rootIndex;

        &#x2F;&#x2F;递归调用 构建子树

        &#x2F;&#x2F;确定左右子树的 前序遍历的边界 
        &#x2F;&#x2F;关键是边界的确定 不懂就画一个简单的出来带入确定

        root-&gt;left&#x3D;  build(preorder,inorder,pre_l+1,pre_l+size_subtree_l,in_l,in_l+size_subtree_l-1);

        root-&gt;right&#x3D; build(preorder,inorder,pre_r-size_subtree_r+1,pre_r,rootIndex+1,in_r);
        return root;

    &#125;
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;

        for(int i&#x3D;0;i&lt;inorder.size();i++)&#123;
            inorderMap[inorder[i]] &#x3D; i;
        &#125;
        int n &#x3D; preorder.size();
        return build(preorder,inorder,0,n-1,0,n-1);

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>
<p><strong>A B C</strong> E<br>S F <strong>C</strong> S<br>A <strong>D</strong> <strong>E</strong> E</p>
<p>示例 1：</p>
<p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true<br>示例 2：</p>
<p>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false</p>
<p>回溯算法 找不到要往后退</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    &#x2F;&#x2F;上下左右四个方向
    int d[4][2] &#x3D; &#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;
    &#x2F;&#x2F;标记是否访问过
    vector&lt;vector&lt;bool&gt;&gt;visited;
    &#x2F;&#x2F;矩阵的行和列
    int m,n;
    &#x2F;&#x2F;判断是否还在矩阵里面
    bool isArea(int x,int y)&#123;
        return x&gt;&#x3D;0&amp;&amp;x&lt;m&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;n;
    &#125;
    &#x2F;&#x2F;搜索函数
    bool searchWord(const vector&lt;vector&lt;char&gt;&gt;&amp; board,const string &amp;word,int index,
    int startx,int starty )&#123;
        &#x2F;&#x2F;递归退出的条件
        if(index&#x3D;&#x3D;word.size()-1)
           return board[startx][starty]&#x3D;&#x3D;word[index];
        &#x2F;&#x2F;如果找到对应字符
        if(board[startx][starty]&#x3D;&#x3D;word[index])&#123;
            &#x2F;&#x2F;标记访问过的位置
            visited[startx][starty]&#x3D;true;
            &#x2F;&#x2F;沿着四个方向继续搜索
            for(int i&#x3D;0;i&lt;4;i++)&#123;
                int newx &#x3D; startx+d[i][0];
                int newy &#x3D; starty+d[i][1];
                &#x2F;&#x2F;如果在四个方向中找下一个字符
                if(isArea(newx,newy)&amp;&amp;!visited[newx][newy]&amp;&amp;
                 searchWord(board,word,index+1,newx,newy))&#123;
                     return true;
                &#125;
            &#125;
            &#x2F;&#x2F;回溯 
            &#x2F;&#x2F;如果四个方向没有找到,回退,则将该字符标记为没有访问
            visited[startx][starty]&#x3D;false;
        &#125;
        return false;
    &#125;
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
        m &#x3D; board.size();
        assert(m&gt;0);
        n &#x3D; board[0].size();
        visited &#x3D; vector&lt;vector&lt;bool&gt;&gt;(m,vector&lt;bool&gt;(n,false));
        for(int i&#x3D;0;i&lt;board.size();i++)&#123;
            for(int j&#x3D;0;j&lt;board[i].size();j++)&#123;
                if(searchWord(board,word,0,i,j))
                    return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<p>输入：m = 2, n = 3, k = 1<br>输出：3<br>示例 2：</p>
<p>输入：m = 3, n = 1, k = 0<br>输出：1</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code>    </li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    int get(int x) &#123;
        int res&#x3D;0;
        for (; x; x &#x2F;&#x3D; 10) &#123;
            res +&#x3D; x % 10;
        &#125;
        return res;
    &#125;

public:
    int movingCount(int m, int n, int k) &#123;
        if (!k) return 1;
        queue&lt;pair&lt;int,int&gt; &gt; Q;
        &#x2F;&#x2F; 向右和向下的方向数组
        int dx[2] &#x3D; &#123;0, 1&#125;;
        int dy[2] &#x3D; &#123;1, 0&#125;;
        vector&lt;vector&lt;int&gt; &gt; vis(m, vector&lt;int&gt;(n, 0));
        Q.push(make_pair(0, 0));
        vis[0][0] &#x3D; 1;
        int ans &#x3D; 1;
        while (!Q.empty()) &#123;
            int x &#x3D; Q.front().first;
            int y &#x3D; Q.front().second;
            Q.pop();
            for (int i &#x3D; 0; i &lt; 2; ++i) &#123;
                int tx &#x3D; dx[i] + x;
                int ty &#x3D; dy[i] + y;
                if (tx &lt; 0 || tx &gt;&#x3D; m || ty &lt; 0 || ty &gt;&#x3D; n || vis[tx][ty] || get(tx) + get(ty) &gt; k) continue;
                Q.push(make_pair(tx, ty));
                vis[tx][ty] &#x3D; 1;
                ans++;
            &#125;
        &#125;
        return ans;


    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>示例 1：</p>
<p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p>
<p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
    private:
        vector&lt;int&gt; memo;
        int max3(int a,int b,int c)&#123;
            return max(a,max(b,c));
        &#125;
        &#x2F;&#x2F;将n进行分割 至少分割两部分 可以获得的最大乘积
        int breakInteger(int n)&#123;
            if(n&#x3D;&#x3D;1)
                return 1;
            if(memo[n]!&#x3D;-1)
                return memo[n];
            int res&#x3D;-1;
            for(int i&#x3D;1;i&lt;n;i++)&#123;
                res &#x3D; max3(res,i*(n-i),i* breakInteger(n-i));
            &#125;
            memo[n] &#x3D; res;
            return res;
        &#125;
    public:
        int cuttingRope(int n) &#123;
            memo &#x3D; vector&lt;int&gt;(n+1,-1);
            int re &#x3D; breakInteger(n);
            return re;
        &#125;
    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    private:
        vector&lt;int&gt; memo;
    
    public:
        int cuttingRope(int n) &#123;
            memo &#x3D; vector&lt;int&gt;(n+1,-1);
            memo[1] &#x3D; 1;
            for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;
                for(int j&#x3D;1;j&lt;i;j++ )&#123;
                    memo[i] &#x3D; max(memo[i],max(j*(i-j),j*memo[i-j]));
                &#125;
            &#125;
            return memo[n];
        &#125;
    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:</p>
<p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p>
<p>提示：</p>
<p>2 &lt;= n &lt;= 1000</p>
<p>​    这一题已经不能用动态规划了，取余之后max函数就不能用来比大小了。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;

public:
    
    int cuttingRope(int n) &#123;
         if(n &#x3D;&#x3D; 2)
            return 1;
        if(n &#x3D;&#x3D; 3)
            return 2;
        long res &#x3D; 1;
        while(n &gt; 4)&#123;
            res *&#x3D; 3;
            res &#x3D; res % 1000000007;
            n -&#x3D; 3;
        &#125;
        return (int)(res * n % 1000000007);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
<p>示例 1：</p>
<p>输入：x = 2.00000, n = 10<br>输出：1024.00000<br>示例 2：</p>
<p>输入：x = 2.10000, n = 3<br>输出：9.26100<br>示例 3：</p>
<p>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25</p>
<p>提示：</p>
<p>-100.0 &lt; x &lt; 100.0<br>-231 &lt;= n &lt;= 231-1<br>-104 &lt;= xn &lt;= 104</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Solution &#123;
public:
    double quickMul(double x, long long N) &#123;
        if (N &#x3D;&#x3D; 0) &#123;
            return 1.0;
        &#125;
        double y &#x3D; quickMul(x, N &#x2F; 2);
        return N % 2 &#x3D;&#x3D; 0 ? y * y : y * y * x;
    &#125;

    double myPow(double x, int n) &#123;
        long long  N &#x3D; n;
        &#x2F;&#x2F;处理正数
        if(N &gt;&#x3D; 0)
            return  quickMul(x, N);
        &#x2F;&#x2F;处理负数
        else
            return 1.0&#x2F;quickMul(x, -N);
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p>
<p>数值（按顺序）可以分成以下几个部分：</p>
<p>若干空格<br>一个 小数 或者 整数<br>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数<br>若干空格<br>小数（按顺序）可以分成以下几个部分：</p>
<p>（可选）一个符号字符（’+’ 或 ‘-‘）<br>下述格式之一：<br>至少一位数字，后面跟着一个点 ‘.’<br>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字<br>一个点 ‘.’ ，后面跟着至少一位数字<br>整数（按顺序）可以分成以下几个部分：</p>
<p>（可选）一个符号字符（’+’ 或 ‘-‘）<br>至少一位数字<br>部分数值列举如下：</p>
<p>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]<br>部分非数值列举如下：</p>
<p>[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</p>
<p>示例 1：</p>
<p>输入：s = “0”<br>输出：true<br>示例 2：</p>
<p>输入：s = “e”<br>输出：false<br>示例 3：</p>
<p>输入：s = “.”<br>输出：false<br>示例 4：</p>
<p>输入：s = “    .1  “<br>输出：true</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 20<br>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，空格 ‘ ‘ 或者点 ‘.’ 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    enum State &#123;
        STATE_INITIAL,
        STATE_INT_SIGN,
        STATE_INTEGER,
        STATE_POINT,
        STATE_POINT_WITHOUT_INT,
        STATE_FRACTION,
        STATE_EXP,
        STATE_EXP_SIGN,
        STATE_EXP_NUMBER,
        STATE_END
    &#125;;

    enum CharType &#123;
        CHAR_NUMBER,
        CHAR_EXP,
        CHAR_POINT,
        CHAR_SIGN,
        CHAR_SPACE,
        CHAR_ILLEGAL
    &#125;;

    CharType toCharType(char ch) &#123;
        if (ch &gt;&#x3D; &#39;0&#39; &amp;&amp; ch &lt;&#x3D; &#39;9&#39;) &#123;
            return CHAR_NUMBER;
        &#125; else if (ch &#x3D;&#x3D; &#39;e&#39; || ch &#x3D;&#x3D; &#39;E&#39;) &#123;
            return CHAR_EXP;
        &#125; else if (ch &#x3D;&#x3D; &#39;.&#39;) &#123;
            return CHAR_POINT;
        &#125; else if (ch &#x3D;&#x3D; &#39;+&#39; || ch &#x3D;&#x3D; &#39;-&#39;) &#123;
            return CHAR_SIGN;
        &#125; else if (ch &#x3D;&#x3D; &#39; &#39;) &#123;
            return CHAR_SPACE;
        &#125; else &#123;
            return CHAR_ILLEGAL;
        &#125;
    &#125;

    bool isNumber(string s) &#123;
        unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123;
            &#123;
                STATE_INITIAL, &#123;
                    &#123;CHAR_SPACE, STATE_INITIAL&#125;,
                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,
                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;,
                    &#123;CHAR_SIGN, STATE_INT_SIGN&#125;
                &#125;
            &#125;, &#123;
                STATE_INT_SIGN, &#123;
                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,
                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;
                &#125;
            &#125;, &#123;
                STATE_INTEGER, &#123;
                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,
                    &#123;CHAR_EXP, STATE_EXP&#125;,
                    &#123;CHAR_POINT, STATE_POINT&#125;,
                    &#123;CHAR_SPACE, STATE_END&#125;
                &#125;
            &#125;, &#123;
                STATE_POINT, &#123;
                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,
                    &#123;CHAR_EXP, STATE_EXP&#125;,
                    &#123;CHAR_SPACE, STATE_END&#125;
                &#125;
            &#125;, &#123;
                STATE_POINT_WITHOUT_INT, &#123;
                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;
                &#125;
            &#125;, &#123;
                STATE_FRACTION,
                &#123;
                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,
                    &#123;CHAR_EXP, STATE_EXP&#125;,
                    &#123;CHAR_SPACE, STATE_END&#125;
                &#125;
            &#125;, &#123;
                STATE_EXP,
                &#123;
                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,
                    &#123;CHAR_SIGN, STATE_EXP_SIGN&#125;
                &#125;
            &#125;, &#123;
                STATE_EXP_SIGN, &#123;
                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;
                &#125;
            &#125;, &#123;
                STATE_EXP_NUMBER, &#123;
                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,
                    &#123;CHAR_SPACE, STATE_END&#125;
                &#125;
            &#125;, &#123;
                STATE_END, &#123;
                    &#123;CHAR_SPACE, STATE_END&#125;
                &#125;
            &#125;
        &#125;;

        int len &#x3D; s.length();
        State st &#x3D; STATE_INITIAL;

        for (int i &#x3D; 0; i &lt; len; i++) &#123;
            CharType typ &#x3D; toCharType(s[i]);
            if (transfer[st].find(typ) &#x3D;&#x3D; transfer[st].end()) &#123;
                return false;
            &#125; else &#123;
                st &#x3D; transfer[st][typ];
            &#125;
        &#125;
        return st &#x3D;&#x3D; STATE_INTEGER || st &#x3D;&#x3D; STATE_POINT || st &#x3D;&#x3D; STATE_FRACTION || st &#x3D;&#x3D; STATE_EXP_NUMBER || st &#x3D;&#x3D; STATE_END;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<pre><code>     3
    / \
   4   5
  / \
 1   2 
</code></pre>
<p>给定的树 B：</p>
<pre class="line-numbers language-none"><code class="language-none">  4 
 &#x2F;
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p>示例 1：</p>
<p>输入：A = [1,2,3], B = [3,1]<br>输出：false<br>示例 2：</p>
<p>输入：A = [3,4,5,1,2], B = [4,1]<br>输出：true<br>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 10000</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    &#x2F;&#x2F;
    bool dfs(TreeNode* a,TreeNode* b)&#123;
        &#x2F;&#x2F;顺序不能反
        if(b&#x3D;&#x3D;NULL)
            return true;
        if(a&#x3D;&#x3D;NULL)
            return false;
       
        return a-&gt;val&#x3D;&#x3D;b-&gt;val&amp;&amp;
        dfs(a-&gt;left,b-&gt;left)&amp;&amp;dfs(a-&gt;right,b-&gt;right);
    &#125;
    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;
        if(A&#x3D;&#x3D;NULL||B&#x3D;&#x3D;NULL)
            return false;

        return dfs(A,B)||isSubStructure(A-&gt;left,B)||isSubStructure(A-&gt;right,B);

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>示例 1：</p>
<p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：</p>
<p>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p>
<p>提示：</p>
<p>0 &lt;= pushed.length == popped.length &lt;= 1000<br>0 &lt;= pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;
        stack&lt;int&gt; s;
        int index &#x3D;0;
        for(auto item:pushed)&#123;
            s.push(item);
            &#x2F;&#x2F;注意这里是while
            while(!s.empty()&amp;&amp;popped[index]&#x3D;&#x3D;s.top())&#123;
                s.pop();
                index++;
            &#125;
        &#125;
        return s.empty();

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;

        queue&lt;TreeNode*&gt; q;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(root &#x3D;&#x3D; NULL) return &#123;&#125;;

        q.push(root);
        int count &#x3D; 0;
        bool needv &#x3D; false;
        vector&lt;int&gt; temp;
        while(!q.empty())&#123;
            int size_q &#x3D; q.size();
            temp.clear();
            for(int i&#x3D;0;i&lt;size_q;i++)&#123;
                TreeNode* t &#x3D;q.front();
                temp.push_back(t-&gt;val);
                if(t-&gt;left!&#x3D;NULL) q.push(t-&gt;left);
                if(t-&gt;right!&#x3D;NULL) q.push(t-&gt;right);
                q.pop();
            &#125;
            if(count%2)
                needv &#x3D; true;
            if(needv)&#123;
                reverse(temp.begin(),temp.end());
                res.push_back(temp);
                needv &#x3D;false;
            &#125;     
            else&#123;
                res.push_back(temp);
            &#125;             
            count++;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<pre class="line-numbers language-none"><code class="language-none">    5
   &#x2F; \
  2   6
 &#x2F; \
1   3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例 1：</p>
<p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p>
<p>输入: [1,3,2,6,5]<br>输出: true</p>
<p>提示：</p>
<p>数组长度 &lt;= 1000</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;考察的应该是二叉搜索树的数组定义和后序遍历
class Solution &#123;
public:
    bool verify(const vector&lt;int&gt;&amp; postorder,int left,int right)&#123;
        if(left&gt;&#x3D;right)
            return true;
        int p &#x3D; left;
        while(postorder[p] &lt; postorder[right]) p++;
        int m &#x3D; p;
        while(postorder[p] &gt; postorder[right]) p++;
        
        return p &#x3D;&#x3D; right 
        &amp;&amp; verify(postorder,left, m - 1)
        &amp;&amp; verify(postorder, m, right - 1);
    &#125;
    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;
        return verify(postorder,0,postorder.size()-1);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>示例 1：</p>
<pre class="line-numbers language-none"><code class="language-none">         5
       &#x2F;   \
      4      8
    &#x2F;       &#x2F;  \
  11       13   4
 &#x2F;  \          &#x2F;  \
7    2        5    1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22
输出：[[5,4,11,2],[5,8,4,5]]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">  1
 &#x2F;  \
2    3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5
输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2], targetSum &#x3D; 0
输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; ret;
    vector&lt;int&gt; path;
    void dfs(TreeNode* root,int target)&#123;

        if(root &#x3D;&#x3D; nullptr)&#123;
            return;
        &#125;
        path.push_back(root-&gt;val);
        target &#x3D; target - root-&gt;val;
        if(root-&gt;left &#x3D;&#x3D; nullptr&amp;&amp;root-&gt;right&#x3D;&#x3D;nullptr&amp;&amp;target&#x3D;&#x3D;0)&#123;
            ret.push_back(path);
        &#125;
        dfs(root-&gt;left,target);
        dfs(root-&gt;right,target);
        path.pop_back();
    &#125;
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int target) &#123;
        dfs(root,target);
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p> 回溯 + 哈希表</p>
<p>注意一个节点可能被多个其他节点指向，因此可能    递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) &#123;
        val &#x3D; _val;
        next &#x3D; NULL;
        random &#x3D; NULL;
    &#125;
&#125;;
*&#x2F;
class Solution &#123;
public:
    unordered_map&lt;Node*,Node*&gt; cacheNode;
    Node* copyRandomList(Node* head) &#123;

        if(head &#x3D;&#x3D; NULL)&#123;
            return NULL;
        &#125;
        if(!cacheNode.count(head))&#123;
            Node* headNew &#x3D; new Node(head-&gt;val);

            cacheNode[head] &#x3D; headNew;

            headNew-&gt;next &#x3D; copyRandomList(head-&gt;next);
            headNew-&gt;random &#x3D; copyRandomList(head-&gt;random);
        &#125;
        return cacheNode[head];
      
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例</p>
<pre class="line-numbers language-none"><code class="language-none">       4
    &#x2F;     \
   2       5
 &#x2F;   \    
1      3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<pre class="line-numbers language-none"><code class="language-none">head
 |
 |
  ---------------------------------------&gt;
 1  -----&gt; 2 ------&gt; 3 ------&gt; 4 ------&gt; 5 
    &lt;-----   &lt;------   &lt;------   &lt;------ 
  &lt;---------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    Node* left;
    Node* right;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val &#x3D; _val;
        left &#x3D; NULL;
        right &#x3D; NULL;
    &#125;

    Node(int _val, Node* _left, Node* _right) &#123;
        val &#x3D; _val;
        left &#x3D; _left;
        right &#x3D; _right;
    &#125;
&#125;;
*&#x2F;
class Solution &#123;
public:
    Node* pre;
    Node* head;
    void dfs(Node* cur)&#123;
        if(cur&#x3D;&#x3D;NULL)&#123;
            return ;
        &#125;
        dfs(cur-&gt;left);

        if(pre&#x3D;&#x3D;NULL)&#123;
             head &#x3D; cur;
        &#125;
        else&#123;
            pre-&gt;right &#x3D; cur;
        &#125;
        cur-&gt;left &#x3D; pre;

        pre &#x3D; cur;

        dfs(cur-&gt;right);
    &#125;
    Node* treeToDoublyList(Node* root) &#123;

        if(root &#x3D;&#x3D; NULL)
            return NULL;
        dfs(root);
        head-&gt;left &#x3D; pre;
        pre-&gt;right &#x3D; head;

        return head;
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例:</p>
<p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p>
<p>限制：</p>
<p>1 &lt;= s 的长度 &lt;= 8</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt;rev;
    vector&lt;int&gt;vis;
    void backtrack(const string &amp; s,int i,int n,string &amp;perm)
    &#123;
        if(i&#x3D;&#x3D;n)
        &#123;
          rev.push_back(perm);
          return ;
        &#125;
        for(int j&#x3D;0;j&lt;n;j++)
        &#123;
            if(vis[j]||(j&gt;0&amp;&amp;!vis[j-1]&amp;&amp;s[j-1]&#x3D;&#x3D;s[j]))
            &#123;
                continue;
            &#125;
            vis[j]&#x3D;true;
            perm.push_back(s[j]);

            backtrack(s,i+1,n,perm);
            
            perm.pop_back();
            vis[j]&#x3D;false;
        &#125;
    &#125;
    vector&lt;string&gt; permutation(string s) &#123;
        int length&#x3D;s.size();
        vis.resize(length);
        sort(s.begin(),s.end());
        string perm;
        backtrack(s,0,length,perm);
        return rev;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findNthDigit(int n) &#123;
        int d &#x3D; 1, count &#x3D; 9;
        while (n &gt; (long) d * count) &#123;
            n -&#x3D; d * count;
            d++;
            count *&#x3D; 10;
        &#125;
        int index &#x3D; n - 1;
        int start &#x3D; (int) pow(10, d - 1);
        int num &#x3D; start + index &#x2F; d;
        int digitIndex &#x3D; index % d;
        int digit &#x3D; (num &#x2F; (int) (pow(10, d - digitIndex - 1))) % 10;
        return digit;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例 1:</p>
<p>输入: [10,2]<br>输出: “102”<br>示例 2:</p>
<p>输入: [3,30,34,5,9]<br>输出: “3033459”</p>
<p>提示:</p>
<p>0 &lt; nums.length &lt;= 100</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;

private:
    &#x2F;&#x2F;关键
    static bool cmp(const string&amp; a,const string &amp;b)&#123;
        return a+b&lt;b+a;
    &#125;
public:

    string minNumber(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;string&gt; strs;
        string res;

        for(auto num:nums)&#123;
            strs.push_back(to_string(num));
        &#125;
        sort(strs.begin(),strs.end(),cmp);
        for(auto str:strs)&#123;
            res+&#x3D;str;
        &#125;
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:</p>
<p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
<p>提示：</p>
<p>0 &lt;= num &lt; 231</p>
<p>动态规划  对比一下打家劫舍</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int translateNum(int num) &#123;
        string src &#x3D; to_string(num);
        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;
        for (int i &#x3D; 0; i &lt; src.size(); ++i) &#123;
            p &#x3D; q; 
            q &#x3D; r; 
            r &#x3D; 0;
            r +&#x3D; q;
            if (i &#x3D;&#x3D; 0) &#123;
                continue;
            &#125;
            auto pre &#x3D; src.substr(i - 1, 2);
            if (pre &lt;&#x3D; &quot;25&quot; &amp;&amp; pre &gt;&#x3D; &quot;10&quot;) &#123;
                r +&#x3D; p;
            &#125;
        &#125;
        return r;
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例 1:</p>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p>
<p>提示：</p>
<p>0 &lt; grid.length &lt;= 200<br>0 &lt; grid[0].length &lt;= 200</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;

        int n &#x3D; grid.size();
        int m &#x3D; grid[0].size();
        &#x2F;&#x2F;dp[i][j]表示从grid[0][0]到grid[i - 1][j - 1]时的最大价值
        vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1));
        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;
            for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;
        dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];
            &#125;
        &#125;
        return dp[n][m];

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) &#123;

        int freq[256]&#x3D;&#123;0&#125;;&#x2F;&#x2F;存ACSII码

        &#x2F;&#x2F;注意这里的定义
        int l &#x3D; 0,r &#x3D;-1;
        int res &#x3D; 0;

        while(l&lt;s.size())&#123;

            &#x2F;&#x2F;如果没有重复的字符
            if(r+1&lt;s.size()&amp;&amp;freq[s[r+1]]&#x3D;&#x3D;0)&#123;
                ++r;
                freq[s[r]]++;
            &#125;
            &#x2F;&#x2F;遇到重复的字符  右指针不动
            &#x2F;&#x2F;左指针右移，并将其在ASCII字符集中的字符减一
            else&#123;
                freq[s[l++]]--;
            &#125;
            &#x2F;&#x2F;
            res &#x3D; max(res,r-l+1);
        &#125;
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:</p>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p>
<p>1 是丑数。<br>n 不超过1690。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;

private:
    int min3(int a,int b,int c)&#123;
        return min(min(a,b),c);
    &#125;
public:
    int nthUglyNumber(int n) &#123;

        vector&lt;int&gt; dp(n+1);
        int p1 &#x3D;1;
        int p2 &#x3D;1;
        int p3 &#x3D;1;
        dp[1]&#x3D;1;
        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;
            int n1 &#x3D; dp[p1]*2;
            int n2 &#x3D; dp[p2]*3;
            int n3 &#x3D; dp[p3]*5;
            dp[i] &#x3D; min3(n1,n2,n3);
            if(dp[i]&#x3D;&#x3D;n1)&#123;
                p1++;
            &#125;
            if(dp[i]&#x3D;&#x3D;n2)&#123;
                p2++;
            &#125;
            if(dp[i]&#x3D;&#x3D;n3)&#123;
                p3++;
            &#125;

        &#125;
        return dp[n];

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>示例 1：</p>
<p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br>示例 2：</p>
<p>输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p>
<p>限制：</p>
<p>2 &lt;= nums.length &lt;= 10000</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;
        int ret &#x3D; 0;
        for (int n : nums)
            ret ^&#x3D; n;
        int div &#x3D; 1;
        while ((div &amp; ret) &#x3D;&#x3D; 0)
            div &lt;&lt;&#x3D; 1;
        int a &#x3D; 0, b &#x3D; 0;
        for (int n : nums)
            if (div &amp; n)
                a ^&#x3D; n;
            else
                b ^&#x3D; n;
        return vector&lt;int&gt;&#123;a, b&#125;;
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例 1：</p>
<p>输入：nums = [3,4,3,3]<br>输出：4<br>示例 2：</p>
<p>输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p>
<p>限制：</p>
<p>1 &lt;= nums.length &lt;= 10000<br>1 &lt;= nums[i] &lt; 2^31</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;
        int ones &#x3D; 0, twos &#x3D; 0;
        for(int num : nums)&#123;
            ones &#x3D; ones ^ num &amp; ~twos;
            twos &#x3D; twos ^ num &amp; ~ones;
        &#125;
        return ones;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值."></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值.</a></h4><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：</p>
<p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p>
<p>限制：</p>
<p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MaxQueue &#123;
    queue&lt;int&gt; q;
    deque&lt;int&gt; d;
public:
    MaxQueue() &#123;
    &#125;
    
    int max_value() &#123;
        if (d.empty())
            return -1;
        return d.front();
    &#125;
    
    void push_back(int value) &#123;
        &#x2F;&#x2F;注意这里是循环 始终维护d头为队列的最大值
        while (!d.empty() &amp;&amp; d.back() &lt; value) &#123;
            d.pop_back();
        &#125;
        d.push_back(value);
        q.push(value);
    &#125;
    
    int pop_front() &#123;
        if (q.empty())
            return -1;
        int ans &#x3D; q.front();
        if (ans &#x3D;&#x3D; d.front()) &#123;
            d.pop_front();
        &#125;
        q.pop();
        return ans;
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a></h4><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p>示例 1:</p>
<p>输入: 1<br>输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]<br>示例 2:</p>
<p>输入: 2<br>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;double&gt; dicesProbability(int n) &#123;
        vector&lt;int&gt; dp(70,0);
        for (int i &#x3D; 1; i &lt;&#x3D; 6; i ++) &#123;
            dp[i] &#x3D; 1;
        &#125;
        for (int i &#x3D; 2; i &lt;&#x3D; n; i ++) &#123;
            for (int j &#x3D; 6*i; j &gt;&#x3D; i; j --) &#123;
                dp[j] &#x3D; 0;
                for (int cur &#x3D; 1; cur &lt;&#x3D; 6; cur ++) &#123;
                    if (j - cur &lt; i-1) &#123;
                        break;
                    &#125;
                    dp[j] +&#x3D; dp[j-cur];
                &#125;
            &#125;
        &#125;
        int all &#x3D; pow(6, n);
        vector&lt;double&gt; ret;
        for (int i &#x3D; n; i &lt;&#x3D; 6 * n; i ++) &#123;
            ret.push_back(dp[i] * 1.0 &#x2F; all);
        &#125;
        return ret;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        if(prices.size()&#x3D;&#x3D;0) return 0;
        int minprices &#x3D; prices[0];
        int maxprofit &#x3D; 0;
       
        for(int i&#x3D;1;i&lt;prices.size();i++)&#123;
            minprices&#x3D;min(minprices,prices[i]);
            maxprofit &#x3D; max(maxprofit,prices[i]-minprices);
        &#125;
        return maxprofit;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例 1：</p>
<p>输入: n = 3<br>输出: 6<br>示例 2：</p>
<p>输入: n = 9<br>输出: 45</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int sumNums(int n) &#123;
        n &amp;&amp; (n +&#x3D; sumNums(n-1));
        return n;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p>示例:</p>
<p>输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123;

        int n &#x3D; a.size();
        if(n&#x3D;&#x3D;0) return &#123;&#125;;
        vector&lt;int&gt;b(n,1);
        b[0]&#x3D;1;
        int temp &#x3D; 1;
        for(int i&#x3D;1;i&lt;n;i++)&#123;
            b[i]&#x3D;b[i-1]*a[i-1];
        &#125;
        for(int j&#x3D; n-2;j&gt;&#x3D;0;j--)&#123;
            temp &#x3D; temp*a[j+1];
            b[j] &#x3D; temp*b[j];
        &#125;
        return b;


    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>返回整数作为最终结果。<br>注意：</p>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p>
<p>示例 1：</p>
<p>输入：s = “42”<br>输出：42<br>解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。<br>第 1 步：”42”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”42”（读入 “42”）<br>           ^<br>解析得到整数 42 。<br>由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。<br>示例 2：</p>
<p>输入：s = “   -42”<br>输出：-42<br>解释：<br>第 1 步：”   -42”（读入前导空格，但忽视掉）<br>            ^<br>第 2 步：”   -42”（读入 ‘-‘ 字符，所以结果应该是负数）<br>             ^<br>第 3 步：”   -42”（读入 “42”）<br>               ^<br>解析得到整数 -42 。<br>由于 “-42” 在范围 [-231, 231 - 1] 内，最终结果为 -42 。<br>示例 3：</p>
<p>输入：s = “4193 with words”<br>输出：4193<br>解释：<br>第 1 步：”4193 with words”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”4193 with words”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”4193 with words”（读入 “4193”；由于下一个字符不是一个数字，所以读入停止）<br>             ^<br>解析得到整数 4193 。<br>由于 “4193” 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</p>
<p>提示：</p>
<p>0 &lt;= s.length &lt;= 200<br>s 由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int strToInt(string str) &#123;
        int i&#x3D;0,sign&#x3D;1,res&#x3D;0;
        while(str[i]&#x3D;&#x3D;&#39; &#39;)i++;
        if(str[i]&#x3D;&#x3D;&#39;-&#39;)sign&#x3D;-1;
        if(str[i]&#x3D;&#x3D;&#39;-&#39;||str[i]&#x3D;&#x3D;&#39;+&#39;)i++;
        while(str[i]&gt;&#x3D;&#39;0&#39;&amp;&amp;str[i]&lt;&#x3D;&#39;9&#39;)&#123;
            if(res*sign&gt;INT_MAX&#x2F;10||(res*sign&#x3D;&#x3D;INT_MAX&#x2F;10&amp;&amp;str[i]-&#39;0&#39;&gt;&#x3D;7))return INT_MAX;
            if(res*sign&lt;INT_MIN&#x2F;10||(res*sign&#x3D;&#x3D;INT_MIN&#x2F;10&amp;&amp;sign*(str[i]-&#39;0&#39;)&lt;&#x3D;-8))return INT_MIN;
            res*&#x3D;10;
            res+&#x3D;(str[i++]-&#39;0&#39;);
        &#125;
        res*&#x3D;sign;
        return res;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a></h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回：</p>
<p>[3,9,20,15,7]</p>
<p>提示：</p>
<p>节点总数 &lt;= 1000</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; levelOrder(TreeNode* root) &#123;

        queue&lt;TreeNode*&gt; q;
        if(root &#x3D;&#x3D; NULL) return &#123;&#125;;
        q.push(root);

        vector&lt;int&gt; rev;
        while(!q.empty())&#123;
            &#x2F;&#x2F;每一层的循环次数
            int n  &#x3D; q.size();
            for(int i&#x3D;0;i&lt;n;i++)&#123;
                TreeNode* t &#x3D; q.front();
                rev.push_back(t-&gt;val);
                if(t-&gt;left!&#x3D;NULL) q.push(t-&gt;left);
                if(t-&gt;right!&#x3D;NULL) q.push(t-&gt;right);
                q.pop();
            &#125;
        &#125;
        return rev;


    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%91%E6%8C%87offer/">
                                    <span class="chip bg-color">剑指offer</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/23/WebServer/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="WebServer">
                        
                        <span class="card-title">WebServer</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            WebServer
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            moseairius
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/WebServer/">
                        <span class="chip bg-color">WebServer</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/10/19/DataStructure/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="DataStructure">
                        
                        <span class="card-title">DataStructure</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Data structure
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-10-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            moseairius
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/data-structure/">
                        <span class="chip bg-color">data structure</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('3'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">moseairius</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "3";
                    var startDate = "14";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="/null" target="_blank">桂ICP备2021002249号-1</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/Moseasirius" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:zhenhaimo@foxmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
