<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mosirius.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C++拾遗">
<meta property="og:type" content="article">
<meta property="og:title" content="C++&#x2F;C拾遗">
<meta property="og:url" content="https://mosirius.cn/2022/03/23/C/index.html">
<meta property="og:site_name" content="moblog">
<meta property="og:description" content="C++拾遗">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mosirius.cn/2022/03/23/C/image-20220306124132731.png">
<meta property="article:published_time" content="2022-03-23T11:22:28.000Z">
<meta property="article:modified_time" content="2022-03-23T12:47:11.981Z">
<meta property="article:author" content="moseairius">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mosirius.cn/2022/03/23/C/image-20220306124132731.png">

<link rel="canonical" href="https://mosirius.cn/2022/03/23/C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++/C拾遗 | moblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">moblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mosirius.cn/2022/03/23/C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="moseairius">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="moblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++/C拾遗
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-23 19:22:28 / 修改时间：20:47:11" itemprop="dateCreated datePublished" datetime="2022-03-23T19:22:28+08:00">2022-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>C++拾遗</p>
<span id="more"></span> 

<h1 id="C-cin-get用法"><a href="#C-cin-get用法" class="headerlink" title="C++ cin.get用法"></a>C++ cin.get用法</h1><p>与字符串输入一样，有时候使用 cin&gt;&gt; 读取字符也不会按我们想要的结果行事。</p>
<p>因为它会忽略掉所有前导白色空格，所以使用 cin&gt;&gt; 就不可能仅输入一个空格或回车符。除非用户输入了空格键、制表符之外的其他字符，否则程序将不可能通过 cin 语句继续执行（一旦输入了这样的字符，在程序可以继续下一个语句之前，仍然需要按回车键）。因此，要求用户“按回车键继续”的程序，不能使用 &gt;&gt; 运算符只读取按回车键的行为。</p>
<p>在这些情况下，cin 对象有一个名为 get 的内置函数很有帮助。因为 get 函数是内置在 cin 对象中的，所以可称之为 cin 的一个成员函数。get 成员函数读取单个字符，包括任何白色空格字符。如果程序需要存储正在读取的字符，则可以通过以下任意一种方式调用 get 成员函数。</p>
<p>在这两个例子中，假设 cin 是正被读入字符的 char 变量的名称：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cin.get (ch);
ch &#x3D; cin.get();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果程序正在使用 get 函数简单地暂停屏幕直到按回车键，并且不需要存储字符，则该函数也可以这样调用：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cin.get();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>请注意，在所有这 3 个编程语句中，get 函数调用的格式实际上是一样的。首先是对象的名称，在此示例中它是 cin。然后是一个句点，其后是被调用的成员函数的名称，在这里当然就是 get。语句的末尾是一组括号和一个表示结束的分号。这是调用任何成员函数的基本格式，如图 1 所示。</p>
<p>使用 get 成员函数的所有 3 种方式：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; This program demonstrates three ways to use cin.get()
&#x2F;&#x2F; to pause a program.
#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    char ch;
    cout &lt;&lt; &quot;This program has paused. Press Enter to continue.&quot;;
    cin.get(ch);
    cout &lt;&lt; &quot;It has paused a second time. Please press Enter again.&quot;;
	ch &#x3D; cin.get();
    cout &lt;&lt; &quot;It has paused a third time. Please press Enter again.&quot;;
    cin.get();
    cout &lt;&lt; &quot;Thank you! \n&quot;;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">This program has paused. Press Enter to continue.
It has paused a second time. Please press Enter again.
It has paused a third time. Please press Enter again.
Thank you!

--------------------------------
Process exited after 8.882 seconds with return value 0
请按任意键继续. . .


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，在 IDE 中运行程序时，当程序终止，则输出窗口会关闭，而 cin.get 函数可用于保持输出屏幕可见。</p>
<h1 id="混合使用-cin-gt-gt-和-cin-get"><a href="#混合使用-cin-gt-gt-和-cin-get" class="headerlink" title="混合使用 cin&gt;&gt; 和 cin.get"></a>混合使用 cin&gt;&gt; 和 cin.get</h1><p>将 cin &gt;&gt; 与 cin.get 混合使用可能会导致烦人且难以发现的问题。</p>
<p>代码段示例：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; This program demonstrates three ways to use cin.get()
&#x2F;&#x2F; to pause a program.
#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    char ch;    &#x2F;&#x2F;定义一个字符变量
	int number; &#x2F;&#x2F;定义一个整型变量
	cout &lt;&lt; &quot;Enter a number:&quot;;
	cin &gt;&gt; number;   &#x2F;&#x2F; 读取整数&#x2F;&#x2F;4行
	cout &lt;&lt; &quot;Enter a character: &quot;;
	ch &#x3D; cin.get() ;   &#x2F;&#x2F; 读取字符&#x2F;&#x2F;6行
	cout &lt;&lt; &quot;Thank You!\n&quot;;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">Enter a number:3
Enter a character: Thank You!

--------------------------------
Process exited after 11.77 seconds with return value 0
请按任意键继续. . .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些语句允许用户输入一个数字，而不是一个字符。看来第 6 行的 cin.get 语句已经被跳过了。这是因为 cin&gt;&gt; 和 cin.get 使用略有不同的技术来读取数据。</p>
<p>在示例代码段中，当执行第 4 行时，用户输入一个数字，然后按回车键。假设输入的是数字 100。按回车键会导致一个换行符(‘\n’)存储在键盘缓冲区数字 100 之后，如图 2 所示。</p>
<img src="/2022/03/23/C/image-20220306124132731.png" class>

<p>当第 4 行中的 cin&gt;&gt; 语句读取用户输入的数据时，它会在遇到换行符时停止。换行字符未被读取，而是仍保留在键盘缓冲区中。从键盘读取数据的输入语句只在键盘缓冲区为空时等待用户输入值，但现在不为空。</p>
<p>当第 6 行中的 cin.get 函数执行时，它开始从先前输入操作停止的键盘缓冲区读取，并发现了换行符，所以它无须等待用户输入另一个值。这种问题最直接的解决办法是使用 cin.ignore 函数。</p>
<h1 id="不定长输入数组"><a href="#不定长输入数组" class="headerlink" title="不定长输入数组"></a>不定长输入数组</h1><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;
int main()&#123;
	
	int a;
	vector&lt;int&gt; re;
	while(cin&gt;&gt;a)&#123;
		re.push_back(a);
		if(getchar()&#x3D;&#x3D;&#39;\n&#39;) &#x2F;&#x2F;遇回车结束
            break;	
	&#125; 
	for(int i&#x3D;0;i&lt;re.size();i++)&#123;
		cout&lt;&lt;re[i]&lt;&lt;&quot; &quot;;
	&#125;
	std::cout&lt;&lt;&quot;Hello&quot;&lt;&lt;endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="C-库函数-printf"><a href="#C-库函数-printf" class="headerlink" title="C 库函数 - printf()"></a>C 库函数 - printf()</h1><p>描述</p>
<p>C 库函数 <strong>int printf(const char *format, …)</strong> 发送格式化输出到标准输出 stdout。</p>
<p>printf()函数的调用格式为:</p>
<pre class="line-numbers language-none"><code class="language-none">printf(&quot;&lt;格式化字符串&gt;&quot;, &lt;参量表&gt;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>声明</p>
<p>下面是 printf() 函数的声明。</p>
<pre class="line-numbers language-none"><code class="language-none">int printf(const char *format, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数</p>
<ul>
<li><strong>format</strong> – 这是字符串，包含了要被写入到标准输出 stdout 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">格式字符</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">d</td>
<td align="left">以十进制形式输出带符号整数(正数不输出符号)</td>
</tr>
<tr>
<td align="left">o</td>
<td align="left">以八进制形式输出无符号整数(不输出前缀0)</td>
</tr>
<tr>
<td align="left">x,X</td>
<td align="left">以十六进制形式输出无符号整数(不输出前缀Ox)</td>
</tr>
<tr>
<td align="left">u</td>
<td align="left">以十进制形式输出无符号整数</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">以小数形式输出单、双精度实数</td>
</tr>
<tr>
<td align="left">e,E</td>
<td align="left">以指数形式输出单、双精度实数</td>
</tr>
<tr>
<td align="left">g,G</td>
<td align="left">以%f或%e中较短的输出宽度输出单、双精度实数</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">输出单个字符</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">输出字符串</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">输出指针地址</td>
</tr>
<tr>
<td align="left">lu</td>
<td align="left">32位无符号整数</td>
</tr>
<tr>
<td align="left">llu</td>
<td align="left">64位无符号整数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">flags（标识）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td>
</tr>
<tr>
<td align="left">空格</td>
<td align="left">如果没有写入任何符号，则在该值前面插入一个空格。</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">width（宽度）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(number)</td>
<td align="left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">.precision（精度）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.number</td>
<td align="left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。</td>
</tr>
<tr>
<td align="left">.*</td>
<td align="left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">length（长度）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">h</td>
<td align="left">参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。</td>
</tr>
<tr>
<td align="left">l</td>
<td align="left">参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td>
</tr>
<tr>
<td align="left">L</td>
<td align="left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</td>
</tr>
</tbody></table>
<ul>
<li><strong>附加参数</strong> – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li>
</ul>
<p>返回值</p>
<p>如果成功，则返回写入的字符总数，否则返回一个负数。</p>
<h1 id="sizeof与strlen"><a href="#sizeof与strlen" class="headerlink" title="sizeof与strlen"></a>sizeof与strlen</h1><p>sizeof与strlen是有着本质的区别，sizeof是求数据类型所占的空间大小,而strlen是求字符串的长度，字符串以/0结尾。区别如下:</p>
<p>(1) sizeof是一个C语言中的一个单目运算符，而strlen是一个函数，用来计算字符串的长度。</p>
<p>(2)sizeof求的是数据类型所占空间的大小，而strlen是求字符串的长度</p>
<p>实例1:</p>
<pre class="line-numbers language-none"><code class="language-none">printf(&quot;char&#x3D;%d&#x2F;n&quot;,sizeof(char));  &#x2F;&#x2F;1
printf(&quot;char*&#x3D;%d&#x2F;n&quot;,sizeof(char*)); &#x2F;&#x2F;4
printf(&quot;int&#x3D;%d&#x2F;n&quot;,sizeof(int)); &#x2F;&#x2F;4
printf(&quot;int*&#x3D;%d&#x2F;n&quot;,sizeof(int*)); &#x2F;&#x2F;4
printf(&quot;long&#x3D;%d&#x2F;n&quot;,sizeof(long)); &#x2F;&#x2F;4
printf(&quot;long*&#x3D;%d&#x2F;n&quot;,sizeof(long*)); &#x2F;&#x2F;4
printf(&quot;double&#x3D;%d&#x2F;n&quot;,sizeof(double)); &#x2F;&#x2F;8
printf(&quot;double*&#x3D;%d&#x2F;n&quot;,sizeof(double*)); &#x2F;&#x2F;4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，char占1个字节，int占4个字节，long点4个字节，而double占8个字节。但 char*,int*,long*,double*都占4个字节的空间。</p>
<p>这是为什么呢？</p>
<p>在C语言中，char,int,long,double这些基本数据类型的长度是由编译器本身决定的。而char*,int*,long*,double*这些都是指针，回想一下，指针就是地址呀，所以里面放的都是地址，而地址的长度当前是由地址总线的位数决定的，现在的计算机一般都是32位的地址总线，也就占4个字节。</p>
<p> 实例2:</p>
<pre class="line-numbers language-none"><code class="language-none">char a[]&#x3D;&quot;hello&quot;;

char b[]&#x3D;&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;

 strlen(a),strlen(b)的值分别是多少?

 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前面分析过，strlen是求字符串的长度，字符串有个默认的结束符/0,这个结束符是在定义字符串的时候系统自动加上去的，就像定义数组a一样。数组a定义了一个字符串，数组b定义了一个字符数组。因此，strlen(a)=5,而strlen(b)的长度就不确定的，因为strlen找不到结束符。</p>
<p>一个比较经典的例子，分析一下:</p>
<pre class="line-numbers language-none"><code class="language-none">char *c&#x3D;&quot;abcdef&quot;;

char d[]&#x3D;&quot;abcdef&quot;;

char e[]&#x3D;&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;&#125;;

 

printf(&quot;%d%d&#x2F;n&quot;,sizeof(c),strlen(c));

printf(&quot;%d%d&#x2F;n&quot;,sizeof(d),strlen(d));

printf(&quot;%d%d&#x2F;n&quot;,sizeof(e),strlen(e));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出的结果是:</p>
<pre class="line-numbers language-none"><code class="language-none">4 6

7 6

6 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>分析一下:</p>
<p>第一行定义c为一个字符指针变量，指向常量字符串，c里面存放的是字符串的首地址。</p>
<p>第二行定义d为一个字符数组，以字符串的形式给这个字符数组赋值。</p>
<p>第三行定义的也是个字符数组，以单个元素的形式赋值。</p>
<p>当以字符串赋值时，”abcdef”,结尾自动加一个”/0”.</p>
<p> strlen(c)遇到/0就会结束，求的是字符串的长度，为6.</p>
<p> sizeof(c)求的是类型空间大小，在前面说过，指针型所点的空间大小是4个字节，系统地址总线长度为32位时。</p>
<p>strlen(d)也是一样，字符串赋值，自动添加/0,求字符串的长度当然是6.</p>
<p>sizeof(d)是求这个数组所占空间的大小，即数组所占内存空间的字节数，应该为7.</p>
<p>sizeof(e), 数组e以单个元素赋值，没有/0结束符，所以所占空间的大小为6个字节。</p>
<p>strlen(e),去找/0结尾的字符串的长度，由于找不到/0，所以返回的值是一个不确定的值。</p>
<h1 id="覆盖-重写-重载"><a href="#覆盖-重写-重载" class="headerlink" title="覆盖 重写 重载"></a>覆盖 重写 重载</h1><h2 id="1、覆盖"><a href="#1、覆盖" class="headerlink" title="1、覆盖"></a>1、覆盖</h2><p>覆盖也称为重写（override）。</p>
<p>覆盖是存在类中，子类重写从基类继承过来的函数，函数名、返回值、参数列表都必须和基类相同。</p>
<p>当子类的对象调用成员函数的时候，如果成员函数有被覆盖则调用子类中覆盖的版本，否则调用从基类继承过来的函数。</p>
<p>如果子类覆盖的是基类的虚函数，则可以用来实现多态。当子类重新定义基类的虚函数之后，基类指针可以根据赋给它不同子类指针动态的调用子类中的虚函数，做到动态绑定，这就是多态。</p>
<h2 id="2、重载"><a href="#2、重载" class="headerlink" title="2、重载"></a>2、重载</h2><p>重载指允许在相同作用域中存在多个同名的函数，这些函数的参数表不同，编译器根据函数不同的形参表对同名函数的名称做修饰，然后这些同名函数就成了不同的函数。如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>重载要求参数列表必须不同，比如参数类型不同、参数个数不同、参数顺序不同。如果仅仅是函数的返回值不同是没办法重载的。如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>函数被C++编译后在符号库中的名字与C语言的不同。假设某个函数的原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该函数被C编译器编译后在符号库中的名字为_foo；而C++编译器则会产生像_foo_int_int之类的名字。</p>
<p>这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。</p>
<h2 id="3、重载与覆盖的区别"><a href="#3、重载与覆盖的区别" class="headerlink" title="3、重载与覆盖的区别"></a>3、重载与覆盖的区别</h2><ul>
<li>重载要求函数名相同，但是参数列表必须不同；覆盖要求函数名、参数列表、返回值必须相同。</li>
<li>重载描述的是同一个类中不同成员函数之间的关系；覆盖是子类和基类之间不同成员函数之间的关系。</li>
<li>重载的确定是在编译时确定，是静态的；虚函数则是在运行时动态确定。</li>
</ul>
<p>在C++语言中有一组基础的概念一直都容易混淆：Overload、Override和Overwrite分别表示什么意思？下面把这三个概念整理一下：</p>
<p><strong>1. Overload（重载）</strong></p>
<p>　　重载的概念最好理解，在同一个类声明范围中，定义了多个名称完全相同、参数（类型或者个数）不相同的函数，就称之为Overload（重载）。重载的特征如下：</p>
<p><strong>（1）</strong>相同的范围（在同一个类中）；<br><strong>（2）</strong>函数名字相同；<br><strong>（3）</strong>参数不同；<br><strong>（4）</strong>virtual 关键字可有可无。</p>
<p><strong>2. Override（覆盖）</strong></p>
<p>　　覆盖的概念其实是用来实现C++多态性的，即子类重新改写父类声明为virtual的函数。Override（覆盖）的特征如下：</p>
<p><strong>（1）</strong>不同的范围（分别位于派生类与基类）；<br><strong>（2）</strong>函数名字相同；<br><strong>（3）</strong>参数列表完全相同；<br><strong>（4）</strong>基类函数必须有virtual 关键字。</p>
<p><strong>3. Overwrite（改写）</strong></p>
<p>　　改写是指派生类的函数屏蔽（或者称之为“隐藏”）了与其同名的基类函数。正是这个C++的隐藏规则使得问题的复杂性陡然增加，这里面分为两种情况讨论：</p>
<p><strong>（1）</strong>如果派生类的函数与基类的函数同名，但是参数不同。那么此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。<br><strong>（2）</strong>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。那么此时，基类的函数被隐藏（注意别与覆盖混淆）。</p>
<p>　　借鉴一个网上的例子来看Overwrite（改写）的情况：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
using namespace std;

class Base
&#123;
public:
    virtual void f(float x)&#123; cout &lt;&lt; &quot;Base::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
    virtual void g(float x)&#123; cout &lt;&lt; &quot;Base::g(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
    void h(float x)&#123; cout &lt;&lt; &quot;Base::h(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
&#125;;

class Derived : public Base
&#123;
public:
    virtual void f(float x)&#123; cout &lt;&lt; &quot;Derived::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
    virtual void g(int x)&#123; cout &lt;&lt; &quot;Derived::g(int) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
    void h(float x)&#123; cout &lt;&lt; &quot;Derived::h(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
&#125;;

int main()
&#123;
    Derived  d;
    Base *pb &#x3D; &amp;d;
    Derived *pd &#x3D; &amp;d;

    &#x2F;&#x2F; Good : behavior depends solely on type of the object
    pb-&gt;f(3.14f); &#x2F;&#x2F; Derived::f(float) 3.14
    pd-&gt;f(3.14f); &#x2F;&#x2F; Derived::f(float) 3.14

    &#x2F;&#x2F; Bad : behavior depends on type of the pointer
    pb-&gt;g(3.14f); &#x2F;&#x2F; Base::g(float) 3.14 (surprise!)
    pd-&gt;g(3.14f); &#x2F;&#x2F; Derived::g(int) 3

    &#x2F;&#x2F; Bad : behavior depends on type of the pointer
    pb-&gt;h(3.14f); &#x2F;&#x2F; Base::h(float) 3.14  (surprise!)
    pd-&gt;h(3.14f); &#x2F;&#x2F; Derived::h(float) 3.14

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 　在上面这个例子中：</p>
<ul>
<li>函数Derived::f(float)覆盖（override）了Base::f(float)。</li>
<li>函数Derived::g(int)改写/隐藏（overwrite）了Base::g(float)。</li>
<li>函数Derived::h(float)改写/隐藏（overwrite）了Base::h(float)。</li>
</ul>
<p><strong>4. 特殊情况说明</strong></p>
<p>　　除了上面讲到的三种情况之外，还有一些比较容易迷惑的地方，例如：</p>
<p><strong>4.1 同名的普通函数与const函数本质上是两个不同的函数，应该等价理解为这两个同名函数的参数是不同的。在派生类中的virtual函数理解上可能会有误解。</strong></p>
<p>　　参见如下例子：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
using namespace std;

class Base
&#123;
public:
    virtual void f(float x)&#123; cout &lt;&lt; &quot;Base::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
&#125;;

class Derived : public Base
&#123;
public:
    virtual void f(float x) const &#123; cout &lt;&lt; &quot;Derived::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;
&#125;;

int main()
&#123;
    Derived  d;
    Base *pb &#x3D; &amp;d;
    Derived *pd &#x3D; &amp;d;

    &#x2F;&#x2F; Bad : behavior depends solely on type of the object
    pb-&gt;f(3.14f); &#x2F;&#x2F; Base::f(float) 3.14
    pd-&gt;f(3.14f); &#x2F;&#x2F; Derived::f(float) 3.14

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>4.2 基类中定义的virtual虚函数，在继承子类中同名函数自动都属于虚函数，可以不需要virtual关键字。</strong></p>
<p><strong>4.3 如果基类中定义的函数不是virtual，而子类中又将相同函数定义为virtual，则称之为越位，函数行为依赖于指针/引用的类型，而不是实际对象的类型。</strong></p>
<p>　　参见如下例子：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;

class Base
&#123;
public:
    void f()&#123; cout &lt;&lt; &quot;Base::f() &quot; &lt;&lt; endl; &#125;
    virtual void g()&#123; cout &lt;&lt; &quot;Base::g() &quot; &lt;&lt; endl; &#125;
&#125;;

class Derived : public Base
&#123;
public:
    virtual void f()&#123; cout &lt;&lt; &quot;Derived::f() &quot; &lt;&lt; endl; &#125;
    void g()&#123; cout &lt;&lt; &quot;Derived::g() &quot; &lt;&lt; endl; &#125;
&#125;;

class VirtualDerived : virtual public Base
&#123;
public:
    void f()&#123; cout &lt;&lt; &quot;VirtualDerived::f() &quot; &lt;&lt; endl; &#125;
    void g()&#123; cout &lt;&lt; &quot;VirtualDerived::g() &quot; &lt;&lt; endl; &#125;
&#125;;

int main()
&#123;
    Base *d &#x3D; new Derived;
    Base *vd &#x3D; new VirtualDerived;

    d-&gt;f(); &#x2F;&#x2F; Base::f() Bad behavior
    d-&gt;g(); &#x2F;&#x2F; Derived::g()

    vd-&gt;f(); &#x2F;&#x2F; Base::f() Bad behavior
    vd-&gt;g(); &#x2F;&#x2F; VirtualDerived::g()

    delete d;
    delete vd;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <strong>5. 针对非虚函数的继承说明</strong></p>
<p>　　在《Effective C++》中讲述了这样一个规则：<strong>任何条件下都要禁止重新定义继承而来的非虚函数。</strong></p>
<p>　　公有继承的含义是 <strong>“是一个”（is a）</strong>，”在一个类中声明一个非虚函数实际上为这个类建立了一种特殊性上的不变性”。如果将这些分析套用到类B、类D和非虚成员函数B::mf，那么:</p>
<p>　　<strong>（1）</strong>适用于B对象的一切也适用于D对象，因为每个D的对象“是一个”B的对象。<br>　　<strong>（2）</strong>B的子类必须同时继承mf的接口和实现，因为mf在B中是非虚函数。</p>
<p>　　那么，如果D重新定义了mf，设计中就会产生矛盾。如果D真的需要实现和B不同的mf，而且每个B的对象（无论怎么特殊）也真的要使用B实现的mf，那么每个D将不 “是一个” B。这种情况下，D不能从B公有继承。相反，如果D真的必须从B公有继承，而且D真的需要和B不同的mf的实现，那么，mf就没有为B反映出特殊性上的不变性。这种情况下，mf应该是虚函数。最后，如果每个D真的 “是一个” B，并且如果mf真的为B建立了特殊性上的不变性，那么，D实际上就不需要重新定义mf，也就决不能这样做。</p>
<p>　　不管采用上面的哪一种论据都可以得出这样的结论：任何条件下都要禁止重新定义继承而来的非虚函数。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/23/WebServer/" rel="prev" title="WebServer">
      <i class="fa fa-chevron-left"></i> WebServer
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/23/ComputerNetwork/" rel="next" title="ComputerNetwork">
      ComputerNetwork <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-cin-get%E7%94%A8%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">C++ cin.get用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8-cin-gt-gt-%E5%92%8C-cin-get"><span class="nav-number">2.</span> <span class="nav-text">混合使用 cin&gt;&gt; 和 cin.get</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8D%E5%AE%9A%E9%95%BF%E8%BE%93%E5%85%A5%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">不定长输入数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%BA%93%E5%87%BD%E6%95%B0-printf"><span class="nav-number">4.</span> <span class="nav-text">C 库函数 - printf()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sizeof%E4%B8%8Estrlen"><span class="nav-number">5.</span> <span class="nav-text">sizeof与strlen</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A6%86%E7%9B%96-%E9%87%8D%E5%86%99-%E9%87%8D%E8%BD%BD"><span class="nav-number">6.</span> <span class="nav-text">覆盖 重写 重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E8%A6%86%E7%9B%96"><span class="nav-number">6.1.</span> <span class="nav-text">1、覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%87%8D%E8%BD%BD"><span class="nav-number">6.2.</span> <span class="nav-text">2、重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E9%87%8D%E8%BD%BD%E4%B8%8E%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.3.</span> <span class="nav-text">3、重载与覆盖的区别</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">moseairius</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">moseairius</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  

</body>
</html>
