<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="thread, moblog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>thread | moblog</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">moblog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">moblog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">thread</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/thread/">
                                <span class="chip bg-color">thread</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-23
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>thread</p>
<span id="more"></span> 

<h1 id="“线程”的起源"><a href="#“线程”的起源" class="headerlink" title="“线程”的起源"></a>“线程”的起源</h1><p>“线程”一词于 1967 年左右被首次提出，是计算机硬件和软件发展过程中诞生的产物。</p>
<p>一台计算机所能利用的资源总是有限的，比如 CPU 在 1 秒钟之内最多执行 1 亿条指令，计算机一共有 1GB 的内存空间等等。因此，“如何提高计算机资源的利用率”是人们一直思考的问题，这个问题也一直带动着计算机硬件和软件的发展。</p>
<p>计算机诞生初期，任何安装任何操作系统和软件，只能运行机器指令，完成一些简单的数学运算。受到当时价格因素的制约，计算机并不普及，拥有者主要是政府、大型机构和公司，一台计算机往往由多个用户共同使用。计算机由专人负责操控，如果有用户想让计算机运行一段指令，必须先将指令输入到打孔卡（一种存储设备）中，然后交给计算机管理员，由计算机管理员负责将指令输入到计算机中执行。</p>
<p>随着对计算机资源利用率的要求不断提升，人们逐渐发现，计算机资源的利用率受管理员的影响非常大。例如，计算机每执行完一个任务，都要等待管理员输入下一个任务，期间很多硬件资源（比如 CPU、某些输入输出设备）都处于空闲状态。</p>
<p>为此，人们设计出了批处理操作系统，由它代替计算机管理员完成任务的切换工作。当计算机执行完某一任务时，批处理系统会自动将下一个要执行的任务输入到计算机中，缩减了任务切换所花费的时间，提高了计算机资源的利用率。</p>
<p>渐渐地人们又发现，批处理系统操控计算机执行的过程中，计算机的 CPU 资源仍经常处于空闲状态。举个例子，当执行中的程序进行 I/O 操作时，CPU 只能等待其 I/O 操作完成后继续工作，这段时间内 CPU 就处于空闲状态。</p>
<p>在批处理系统（又称单道批处理操作系统）的基础上，人们又设计出了功能更强大的多道批处理操作系统。和先前的系统相比，多道批处理系统主要有以下两点优势：</p>
<ul>
<li>它将计算机的内存分成很多区域，每个区域都可以存储一个程序；</li>
<li>当执行的程序执行 I/O 操作时，操作系统会将 CPU 资源分配给其它等待执行的程序。</li>
</ul>
<p>也就是说，多道批处理操作系统可以“同时”执行多个程序，这样的操作系统又称多任务操作系统。为了使多任务系统更高效地完成计算机资源的分配和回收，便于管理各个程序的执行过程，人们提出了“进程”的概念。</p>
<p>所谓进程，指的就是正在执行的应用程序。多任务操作系统可以控制各个进程的执行状态，例如终止某个正在执行的进程，启动某个暂停执行的进程等。操作系统负责为每个进程分配独立的内存空间和其它所需资源（例如 I/O 设备、文件等），进程执行完毕后，操作系统会将进程占用的资源全部回收。</p>
<p>早期的多任务操作系统，以进程为单位管理各个程序的运行以及计算机资源的分配和回收，进一步提高了计算机资源的利用率。但随着计算机硬、软件的发展，人们发现还可以做进一步优化，例如：</p>
<ul>
<li>操作系统将 CPU 资源从一个进程分配给另一个进程时，开销较大；</li>
<li>各个进程占用的内存空间是相互独立的，大大增加了进程间通信的实现难度；</li>
<li>一个进程可能会执行多个任务，当某个任务因 I/O 操作暂停执行时，其他任务将无法执行。</li>
</ul>
<p>在计算机软、硬件快速发展，人们计算机运行效率的要求越来越高的大背景下，“线程”应运而生。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>我们知道，一个进程指的是一个正在执行的应用程序。线程对应的英文名称为“thread”，它的功能是执行应用程序中的某个具体任务，比如一段程序、一个函数等。</p>
<p>线程和进程之间的关系，类似于工厂和工人之间的关系，进程好比是工厂，线程就如同工厂中的工人。一个工厂可以容纳多个工人，工厂负责为所有工人提供必要的资源（电力、产品原料、食堂、厕所等），所有工人共享这些资源，每个工人负责完成一项具体的任务，他们相互配合，共同保证整个工厂的平稳运行。</p>
<p>每个进程执行前，操作系统都会为其分配所需的资源，包括要执行的程序代码、数据、内存空间、文件资源等。一个进程至少包含 1 个线程，可以包含多个线程，所有线程共享进程的资源，各个线程也可以拥有属于自己的私有资源。</p>
<blockquote>
<p>进程仅负责为各个线程提供所需的资源，真正执行任务的是线程，而不是进程。</p>
</blockquote>
<p>下图描述了进程和线程之间的关系：</p>
<img src="/2022/03/23/thread/image-20220305230343742.png" class>

<p>如图所示，所有线程共享的进程资源有：</p>
<ul>
<li>代码：即应用程序的代码；</li>
<li>数据：包括全局变量、函数内的静态变量、堆空间的数据等；</li>
<li>进程空间：操作系统分配给进程的内存空间；</li>
<li>打开的文件：各个线程打开的文件资源，也可以为所有线程所共享，例如线程 A 打开的文件允许线程 B 进行读写操作。</li>
</ul>
<p>各个线程也可以拥有自己的私有资源，包括寄存器中存储的数据、线程执行所需的局部变量（函数参数）等。</p>
<h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><p>所谓多线程，即一个进程中拥有多（≥2）个线程，线程之间相互协作、共同执行一个应用程序。</p>
<p>我们通常将以“多线程”方式编写的程序称为“多线程程序”，将编写多线程程序的过程称为“多线程编程”，将拥有多个线程的进程称为“多线程进程”。</p>
<blockquote>
<p>当进程中仅包含 1 个执行程序指令的线程时，该线程又称“主线程”，这样的进程称为“单线程进程”。</p>
</blockquote>
<p>如今，很多应用程序（软件）都是多线程程序，例如 QQ 具备同时和多人聊天的能力、迅雷具备同时下载多个资源的能力、很多杀毒软件可以同时开启杀毒、清理垃圾、电脑加速等功能。</p>
<h1 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h1><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>
<h1 id="Windows线程的创建和使用"><a href="#Windows线程的创建和使用" class="headerlink" title="Windows线程的创建和使用"></a>Windows线程的创建和使用</h1><h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p>C++ 11 之后添加了新的标准线程库 <strong>std::thread</strong>，<strong>std::thread</strong> <strong>在 <thread></thread></strong> 头文件中声明，因此使用 <strong>std::thread</strong> 时需要包含 <strong>在 <thread></thread></strong> 头文件。</p>
<p>之前一些编译器使用 C++ 11 的编译参数是 <strong>-std=c++11</strong>:</p>
<pre class="line-numbers language-none"><code class="language-none">g++ -std&#x3D;c++11 test.cpp <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>std::thread</strong> 默认构造函数，创建一个空的 <strong>std::thread</strong> 执行对象。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;thread&gt;
std::thread thread_object(callable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>一个可调用对象可以是以下三个中的任何一个：</p>
<ul>
<li>函数指针</li>
<li>函数对象</li>
<li>lambda 表达式</li>
</ul>
<p>定义 callable 后，将其传递给 <strong>std::thread</strong> 构造函数 <strong>thread_object</strong>。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 演示多线程的CPP程序
&#x2F;&#x2F; 使用三个不同的可调用对象
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;
 
&#x2F;&#x2F; 一个虚拟函数
void foo(int Z)
&#123;
    for (int i &#x3D; 0; i &lt; Z; i++) &#123;
        cout &lt;&lt; &quot;线程使用函数指针作为可调用参数\n&quot;;
    &#125;
&#125;
 
&#x2F;&#x2F; 可调用对象
class thread_obj &#123;
public:
    void operator()(int x)
    &#123;
        for (int i &#x3D; 0; i &lt; x; i++)
            cout &lt;&lt; &quot;线程使用函数对象作为可调用参数\n&quot;;
    &#125;
&#125;;
 
int main()
&#123;
    cout &lt;&lt; &quot;线程 1 、2 、3 &quot;
         &quot;独立运行&quot; &lt;&lt; endl;
 
    &#x2F;&#x2F; 函数指针
    thread th1(foo, 3);
 
    &#x2F;&#x2F; 函数对象
    thread th2(thread_obj(), 3);
 
    &#x2F;&#x2F; 定义 Lambda 表达式
    auto f &#x3D; [](int x) &#123;
        for (int i &#x3D; 0; i &lt; x; i++)
            cout &lt;&lt; &quot;线程使用 lambda 表达式作为可调用参数\n&quot;;
    &#125;;
 
    &#x2F;&#x2F; 线程通过使用 lambda 表达式作为可调用的参数
    thread th3(f, 3);
 
    &#x2F;&#x2F; 等待线程完成
    
    &#x2F;&#x2F; 等待线程 t1 完成
    th1.join();
 
    &#x2F;&#x2F; 等待线程 t2 完成
    th2.join();
 
    &#x2F;&#x2F; 等待线程 t3 完成
    th3.join();
 
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">线程 1 、2 、3 独立运行
线程使用函数指针作为可调用参数
线程使用函数指针作为可调用参数
线程使用函数指针作为可调用参数
线程使用 lambda 表达式作为可调用参数
线程使用 lambda 表达式作为可调用参数
线程使用 lambda 表达式作为可调用参数
线程使用函数对象作为可调用参数
线程使用函数对象作为可调用参数
线程使用函数对象作为可调用参数

--------------------------------
Process exited after 0.02723 seconds with return value 0
请按任意键继续. . .




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id><a href="#" class="headerlink" title></a></h1><p>C++11 标准中，<code>&lt;thread&gt;</code>头文件提供了 thread 类（位于 std 命令空间中），专门用来完成线程的创建和使用。</p>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>一个线程可以用 thread 类的对象来表示，thread类中重载了多种构造函数，最常用的有以下两个：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1、Fn 表示线程要执行的函数，args 表示向 Fn 传递的多个参数，此构造函数支持泛型
template &lt;class Fn, class... Args&gt;
explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;... args);
&#x2F;&#x2F;2、移动构造函数
thread (thread&amp;&amp; x) noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。
explicit使用注意事项:

      explicit 关键字只能用于类内部的构造函数声明上。
      explicit 关键字作用于单个参数的构造函数。
跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).


 explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。

 google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。
　　effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>thread 类只提供了移动构造函数，未提供拷贝构造函数。这意味着，我们不能直接将一个事先定义好的 thread 对象赋值给另一个 thread 对象，但可以将临时的（匿名的）thread 对象赋值给另一个 thread 对象。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;
void threadFun1(int n) &#123;
    cout &lt;&lt; &quot;---thread1 running\n&quot;;
    cout &lt;&lt; &quot;n&#x3D;&quot; &lt;&lt; n &lt;&lt; endl;
&#125;
void threadFun2(const char * url) &#123;
    cout &lt;&lt; &quot;---thread2 running\n&quot;;
    cout &lt;&lt; &quot;url&#x3D;&quot; &lt;&lt; url &lt;&lt; endl;
&#125;
int main() &#123;
    &#x2F;&#x2F;调用第 1 种构造函数
    thread thread1(threadFun1,10);
    &#x2F;&#x2F;调用移动构造函数
    thread thread2 &#x3D; std::thread(threadFun2,&quot;http:&#x2F;&#x2F;google.com&quot;);
    &#x2F;&#x2F;阻塞主线程，等待 thread1 线程执行完毕
    thread1.join();
    &#x2F;&#x2F;阻塞主线程，等待 thread2 线程执行完毕
    thread2.join();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">---thread1 running
n&#x3D;10
---thread2 running
url&#x3D;http:&#x2F;&#x2F;google.com

--------------------------------
Process exited after 0.02249 seconds with return value 0
请按任意键继续. . .


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">---thread1 running
n&#x3D;---thread2 running
url&#x3D;http:&#x2F;&#x2F;google.com10


--------------------------------
Process exited after 0.02315 seconds with return value 0
请按任意键继续. . .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序执行结果为（不唯一）：为什么？</p>
<p>程序中，分别调用两种构造函数创建了两个线程，它们分别执行 threadFun1() 和 threadFun2() 函数。我们在主线程（main() 函数）中调用了 thread 类提供的 join() 成员函数，以 thread1.join() 为例，它的功能是阻塞主线程，直至 thread1 线程执行完毕后，主线程才能继续执行。</p>
<h4 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h4><p>除了 join() 成员函数外，thread 类还提供有很多实用的成员函数，表 1 给大家列出了几个最常用的函数：</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>get_id()</td>
<td>获取当前 thread 对象的线程 ID。</td>
</tr>
<tr>
<td>joinable()</td>
<td>判断当前线程是否支持调用 join() 成员函数。</td>
</tr>
<tr>
<td>join()</td>
<td>阻塞当前 thread 对象所在的线程，直至 thread 对象表示的线程执行完毕后，所在线程才能继续执行。</td>
</tr>
<tr>
<td>detach()</td>
<td>将当前线程从调用该函数的线程中分离出去，它们彼此独立执行。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个线程的状态。</td>
</tr>
</tbody></table>
<p>注意，每个thread 对象在调用析构函数销毁前，要么调用 join() 函数令主线程等待子线程执行完成，要么调用 detach() 函数将子线程和主线程分离，两者比选其一，否则程序可能存在以下两个问题：</p>
<ul>
<li>线程占用的资源将无法全部释放，造成内存泄漏；</li>
<li>当主线程执行完成而子线程未执行完时，程序执行将引发异常。</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;thread&gt;
&#x2F;&#x2F;#include &lt;unistd.h&gt; &#x2F;&#x2F;Linux
#include &lt;Windows.h&gt; &#x2F;&#x2F;Windows
using namespace std;
void threadFun1(int n) &#123;
&#x2F;&#x2F;    sleep(5);&#x2F;&#x2F;Linux
    Sleep(5);&#x2F;&#x2F;Windows
    cout &lt;&lt; &quot;---thread1 running\n&quot;;
    cout &lt;&lt; &quot;n&#x3D;&quot; &lt;&lt; n &lt;&lt; endl;
&#125;
void threadFun2(const char * url) &#123;
    cout &lt;&lt; &quot;---thread2 running\n&quot;;
    cout &lt;&lt; &quot;url&#x3D;&quot; &lt;&lt; url &lt;&lt; endl;
&#125;
int main() &#123;
    &#x2F;&#x2F;调用第 1 种构造函数
    thread thread1(threadFun1, 10);
    &#x2F;&#x2F;输出 thread1 线程的 ID
    cout &lt;&lt; &quot;thread1 ID:&quot; &lt;&lt; thread1.get_id() &lt;&lt; endl;
    &#x2F;&#x2F;调用移动构造函数
    thread thread2 &#x3D; std::thread(threadFun2, &quot;http:&#x2F;&#x2F;mozhenahi.com&quot;);
    &#x2F;&#x2F;输出 thread2 线程的 ID
    cout &lt;&lt; &quot;thread2 ID:&quot; &lt;&lt; thread2.get_id() &lt;&lt; endl;
    &#x2F;&#x2F;将 thread1 与主线程分离开，thread1 线程独立执行。
    thread1.detach();
    &#x2F;&#x2F;判断 thread2 线程是否可以调用 join() 函数
    if (thread2.joinable()) &#123;
        &#x2F;&#x2F;阻塞主线程，直至 thread2 线程执行完毕。
        thread2.join();
    &#125;
    cout &lt;&lt; &quot;main finished&quot; &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">thread1 ID:2
thread2 ID:3
---thread2 running
url&#x3D;http:&#x2F;&#x2F;mozhenahi.com
main finished

--------------------------------
Process exited after 0.02273 seconds with return value 0
请按任意键继续. . .


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序中创建了 2 个线程，通过调用 get_id() 成员函数分别获得了它们的线程 ID，其中 thread1 线程独立执行，thread2 线程先于主线程执行完成。通过执行结果可以看到，thread1 线程的执行结果并没有显示到屏幕上，这是因为 thread1 线程还未执行输出语句，主线程就已经执行结束（整个进程也执行结束），thread1 线程无法将执行结果输出到屏幕上。</p>
<p><code>&lt;thread&gt;</code>头文件中不仅定义了 thread 类，还提供了一个名为 this_thread 的命名空间，此空间中包含一些功能实用的函数，如表 2</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>get_id()</td>
<td>获得当前线程的 ID。</td>
</tr>
<tr>
<td>yield()</td>
<td>阻塞当前线程，直至条件成熟。</td>
</tr>
<tr>
<td>sleep_until()</td>
<td>阻塞当前线程，直至某个时间点为止。</td>
</tr>
<tr>
<td>sleep_for()</td>
<td>阻塞当前线程指定的时间（例如阻塞 5 秒）。</td>
</tr>
</tbody></table>
<h2 id="实现线程同步"><a href="#实现线程同步" class="headerlink" title="实现线程同步"></a>实现线程同步</h2><p>C++ 11 标准为解决“线程间抢夺公共资源”提供了多种方案，其中就包括我们前面讲到的互斥锁和条件变量。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>考虑到不同场景的需要，C++ 11 标准提供有多种互斥锁，比如递归互斥锁、定时互斥锁，自动“加锁”和“解锁”的互斥锁等。本节我们以普通的互斥锁为例，给大家讲解互斥锁的基本用法。</p>
<p>C++11标准规定，互斥锁用 mutex 类（位于 std 命名空间中）的对象表示，该类定义在<code>&lt;mutex&gt;</code>头文件中。mutex 类提供有 lock() 和 unlock() 成员函数，分别完成“加锁”和“解锁”功能。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;mutex&gt;          &#x2F;&#x2F; std::mutex
#include &lt;chrono&gt;         &#x2F;&#x2F; std::chrono::seconds()
#include &lt;thread&gt;
#include &lt;iostream&gt;
using namespace std;
int  n &#x3D; 0;
std::mutex mtx;           &#x2F;&#x2F; 定义一个 mutex 类对象，创建一个互斥锁
void threadFun() &#123;
    while(n&lt;10)&#123;
        &#x2F;&#x2F;对互斥锁进行“加锁”
        mtx.lock();
        n++;
        cout &lt;&lt; &quot;ID&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; n &#x3D; &quot;&lt;&lt; n &lt;&lt; endl;
        &#x2F;&#x2F;对互斥锁进行“解锁”
        mtx.unlock();
        &#x2F;&#x2F;暂停 1 秒
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;
int main()
&#123;
    thread th1(threadFun);
    thread th2(threadFun);
    th1.join();
    th2.join();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序执行结果为（不唯一）：</p>
<pre class="line-numbers language-none"><code class="language-none">ID2 n &#x3D; 1
ID3 n &#x3D; 2
ID3 n &#x3D; 3
ID2 n &#x3D; 4
ID3 n &#x3D; 5
ID2 n &#x3D; 6
ID3 n &#x3D; 7
ID2 n &#x3D; 8
ID3 n &#x3D; 9
ID2 n &#x3D; 10

--------------------------------
Process exited after 5.044 seconds with return value 0
请按任意键继续. . .




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ID2 n &#x3D; 1
ID3 n &#x3D; 2
ID2 n &#x3D; 3
ID3 n &#x3D; 4
ID2 n &#x3D; 5
ID3 n &#x3D; 6
ID2 n &#x3D; 7
ID3 n &#x3D; 8
ID3 n &#x3D; 9
ID2 n &#x3D; 10

--------------------------------
Process exited after 5.044 seconds with return value 0
请按任意键继续. . .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序中，访问公共变量 n 的线程有 2 个，为了避免它们之间竞争资源，对 threadFun() 函数中访问 n 变量的过程引入了互斥锁机制。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>C++ 11标准提供了两种表示条件变量的类，分别是 condition_variable 和 condition_variable_any，它们都定义在<code>&lt;condition_variable&gt;</code>头文件中。我们知道，为了避免线程间抢夺资源，条件变量通常和互斥锁搭配使用，condition_variable 类表示的条件变量只能和 unique_lock 类表示的互斥锁（可自行加锁和解锁）搭配使用，而 condition_variable_any 类表示的条件变量可以和任意类型的互斥锁搭配使用（例如递归互斥锁、定时互斥锁等）。</p>
<p>condition_variable_any 类的对象都表示一个条件变量，该类提供的成员函数如表 </p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>wait()</td>
<td>阻塞当前线程，等待条件成立。</td>
</tr>
<tr>
<td>wait_for()</td>
<td>阻塞当前线程的过程中，该函数会自动调用 unlock() 函数解锁互斥锁，从而令其他线程使用公共资源。当条件成立或者超过了指定的等待时间（比如 3 秒），该函数会自动调用 lock() 函数对互斥锁加锁，同时令线程继续执行。</td>
</tr>
<tr>
<td>wait_until()</td>
<td>和 wait_for() 功能类似，不同之处在于，wait_until() 函数可以设定一个具体时间点（例如 2021年4月8日 的某个具体时间），当条件成立或者等待时间超过了指定的时间点，函数会自动对互斥锁加锁，同时线程继续执行。</td>
</tr>
<tr>
<td>notify_one()</td>
<td>向其中一个正在等待的线程发送“条件成立”的信号。</td>
</tr>
<tr>
<td>notify_all()</td>
<td>向所有等待的线程发送“条件成立”的信号。</td>
</tr>
</tbody></table>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;thread&gt;             &#x2F;&#x2F; std::thread
#include &lt;mutex&gt;              &#x2F;&#x2F; std::mutex, std::unique_lock
#include &lt;condition_variable&gt; &#x2F;&#x2F; std::condition_variable_any
#include &lt;chrono&gt;         &#x2F;&#x2F; std::chrono::seconds()
&#x2F;&#x2F;创建一个互斥锁
std::mutex mtx;
&#x2F;&#x2F;创建一个条件变量
std::condition_variable_any cond;
void print_id() &#123;
    mtx.lock();
    &#x2F;&#x2F;阻塞线程，直至条件成立
    cond.wait(mtx);
    std::cout &lt;&lt; &quot;----threadID &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt;&quot; run&quot; &lt;&lt; std::endl;
    &#x2F;&#x2F;等待 2 秒
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mtx.unlock();
&#125;
void go() &#123;
    std::cout &lt;&lt; &quot;go running\n&quot;;
    &#x2F;&#x2F;阻塞线程 2 秒钟
    std::this_thread::sleep_for(std::chrono::seconds(2));
    &#x2F;&#x2F;通知所有等待的线程条件成立
    cond.notify_all();
&#125;
int main()
&#123;
    &#x2F;&#x2F;创建 4 个线程执行 print_id() 函数
    std::thread threads[4];
    for (int i &#x3D; 0; i &lt; 4; ++i)
        threads[i] &#x3D; std::thread(print_id);
    &#x2F;&#x2F;创建 1 个线程执行 go() 函数
    std::thread goThread(go);
    &#x2F;&#x2F;等待所有线程执行结果后，主线程才能继续执行
    goThread.join();
    for (auto&amp; th : threads) &#123;
        th.join();
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">go running
----threadID 2 run
----threadID 4 run
----threadID 5 run
----threadID 3 run

--------------------------------
Process exited after 10.04 seconds with return value 0
请按任意键继续. . .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Windows平台，Windows API提供了对多线程的支持。前面进程和线程的概念中我们提到，一个程序至少有一个线程，这个线程称为主线程(main thread)，如果我们不显示地创建线程，那我们产的程序就是只有主线程的间线程程序。</p>
<h1 id="Linux线程的创建和使用"><a href="#Linux线程的创建和使用" class="headerlink" title="Linux线程的创建和使用"></a>Linux线程的创建和使用</h1><h2 id="lt-pthread-h-gt"><a href="#lt-pthread-h-gt" class="headerlink" title="&lt;pthread.h&gt;"></a>&lt;pthread.h&gt;</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">功能：
    创建一个线程
原型：
    <span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span>
                          <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
参数：  
    thread ： 返回线程ID
    attr ： 设置线程属性，为<span class="token constant">NULL</span>时表示使用默认属性
    start_routine ： 是个函数地址，线程启动后要执行的函数
    arg ： 传给线程启动函数的参数
返回值：
    成功 ：<span class="token number">0</span>
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    线程终止
原型：
    void pthread_exit(void *retval);
参数：  
    retval ：retval不要指向一个局部变量 
返回值：
    无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    等待线程结束
原型：
    int pthread_join(pthread_t thread, void **retval);
参数：  
    thread ：线程ID
    retval ： 它指向一个指针，指向线程的返回值
    
返回值：
    成功 ： 0
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    分离线程
原型：
    int pthread_detach(pthread_t thread);
参数：  
    thread ：线程ID
    
返回值：
    成功 ： 0
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    返回线程的ID
原型：
    int pthread_self(void);    
返回值：
    总是成功，返回调用此函数的线程ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-cancle"><a href="#pthread-cancle" class="headerlink" title="pthread_cancle"></a>pthread_cancle</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    取消一个执行中的线程
原型：
    int pthread_cancel(pthread_t thread); 
参数：
    thread ： 线程ID
返回值：
    成功 ： 0
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h3><ul>
<li>传统的一些函数是，成功返回0， 失败返回-1，并且对全局变量errno赋值以指示错误</li>
<li>pthread函数出错时不会设置全局变量errno（而大部分其它POSIX函数会这样做）。而是将错误代码通过返回值返回</li>
<li>pthread同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthread函数的错误设置，建议通过返回值判定，因为读取返回值要比读取线程内的errno变量的开销更小</li>
</ul>
<h3 id="进程线程对比"><a href="#进程线程对比" class="headerlink" title="进程线程对比"></a>进程线程对比</h3><table>
<thead>
<tr>
<th>属性</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>pid_t</td>
<td>pthread_t</td>
</tr>
<tr>
<td>创建</td>
<td>fork</td>
<td>pthread_create</td>
</tr>
<tr>
<td>等待</td>
<td>waitpid</td>
<td>pthread_join</td>
</tr>
<tr>
<td>僵尸</td>
<td>waitpid</td>
<td>pthread_join、pthread_detach</td>
</tr>
<tr>
<td>退出（自杀）</td>
<td>exit,return</td>
<td>pthread_exit,return</td>
</tr>
<tr>
<td>他杀</td>
<td>kill</td>
<td>pthread_cancel</td>
</tr>
</tbody></table>
<h2 id="用线程实现回射客户端、服务器端"><a href="#用线程实现回射客户端、服务器端" class="headerlink" title="用线程实现回射客户端、服务器端"></a>用线程实现回射客户端、服务器端</h2><p><strong>pserver.c</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">include &lt;unistd.h&gt;
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;socket.h&gt;
#include &lt;netinet&#x2F;in.h&gt;
#include &lt;arpa&#x2F;inet.h&gt;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define ERR_EXIT(m)\
    do\
&#123;\
    perror(m);\
    exit(EXIT_FAILURE);\
&#125;while(0)


void do_service(int conn)
&#123;
    char recvbuf[1024] &#x3D; &#123;0&#125;;
    while(1)
    &#123;   
        memset(recvbuf,0,sizeof(recvbuf));
        int ret &#x3D; read(conn,recvbuf,sizeof(recvbuf));
        if(ret &#x3D;&#x3D; 0)
        &#123;
            printf(&quot;client close\n&quot;);
            break;
        &#125;
        else if(ret &#x3D;&#x3D; -1)
            ERR_EXIT(&quot;read&quot;);
        fputs(recvbuf,stdout);
        write(conn,recvbuf,ret);
    &#125;
&#125;

void* thread_routine(void *arg)
&#123;
    pthread_detach(pthread_self());

    &#x2F;&#x2F; 使用取地址的方式获取
    &#x2F;&#x2F;int conn &#x3D; *((int*)arg);
    
    &#x2F;&#x2F; 使用强制转换的方式获取
    &#x2F;&#x2F; int conn &#x3D; (int)arg;

    &#x2F;&#x2F; 使用取地址的方式获取，释放空间
    int conn &#x3D; *((int*)arg);
    free(arg);

    do_service(conn);
    printf(&quot;exit thread %lu ...\n&quot;,pthread_self());
    return NULL;
&#125;

int main(void)
&#123;
    int listenfd;
    if((listenfd &#x3D; socket(PF_INET,SOCK_STREAM,IPPROTO_TCP)) &lt; 0)
        ERR_EXIT(&quot;socket&quot;);

    struct sockaddr_in serv_addr;
    memset(&amp;serv_addr,0,sizeof(serv_addr)); 
    serv_addr.sin_family &#x3D; AF_INET;
    serv_addr.sin_port &#x3D; htons(5188);
    serv_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);
    &#x2F;&#x2F;  serv_addr.sin_addr.s_addr &#x3D; inet_addr(&quot;127.0.0.1&quot;);
    &#x2F;&#x2F;  inet_aton(&quot;127.0.0.1&quot;,&amp;serv_addr.sin_addr);

    int on &#x3D; 1;
    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,&amp;on,sizeof(on)) &lt; 0)
        ERR_EXIT(&quot;setsockopt&quot;);
    if(bind(listenfd, (struct sockaddr*)(&amp;serv_addr), sizeof(serv_addr)) &lt; 0)
        ERR_EXIT(&quot;bind&quot;);

    if(listen(listenfd, SOMAXCONN) &lt; 0)
        ERR_EXIT(&quot;listen&quot;);

    struct sockaddr_in cli_addr;
    socklen_t cli_len &#x3D; sizeof(cli_addr);
    int conn;

    while(1)
    &#123;
        if((conn &#x3D; accept(listenfd, (struct sockaddr *)(&amp;cli_addr), &amp;cli_len)) &lt; 0)
            ERR_EXIT(&quot;accept&quot;);

        printf(&quot;ip : %s port : %d\n&quot;,inet_ntoa(cli_addr.sin_addr),ntohs(cli_addr.sin_port));

        pthread_t tid;
        int ret;
        &#x2F;&#x2F; 使用这种方式存在一定的问题，因为是&amp;conn,如果accept返回后，thread_routine还没有来得及处理上一个conn，conn将被改变，导致上一次连接无法处理
        &#x2F;&#x2F; 最好不要使用指针传递，应使用值传递；
        &#x2F;&#x2F;if( (ret &#x3D; pthread_create(&amp;tid, NULL, thread_routine, (void*)&amp;conn)) !&#x3D; 0 )

        &#x2F;&#x2F;使用这种方式，将int类型装换成无类型指针，int是4个字节，指针也是4个字节；但是这种做法是不可移植的，不同的操作系统，指针所占的字节数不一样
        &#x2F;&#x2F; if( (ret &#x3D; pthread_create(&amp;tid, NULL, thread_routine, (void*)conn)) !&#x3D; 0 )

        &#x2F;&#x2F;申请一块单独的内存放conn,取出后释放掉
        int *p &#x3D; malloc(sizeof(int));
        *p &#x3D; conn; 
        if( (ret &#x3D; pthread_create(&amp;tid, NULL, thread_routine, p)) !&#x3D; 0 )
        &#123;
            fprintf(stderr, &quot;pthread_create : %s\n&quot;, strerror(ret));
            exit(EXIT_FAILURE);
        &#125;

    &#125;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>pclient.c</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;socket.h&gt;
#include &lt;netinet&#x2F;in.h&gt;
#include &lt;arpa&#x2F;inet.h&gt;
#include &lt;signal.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#define ERR_EXIT(m)\
    do\
&#123;\
    perror(m);\
    exit(EXIT_FAILURE);\
&#125;while(0)


void handler(int sig)
&#123;
    printf(&quot;recv a sig :%d\n&quot;,sig);
    exit(EXIT_SUCCESS);
&#125;

int main(void)
&#123;
    int sock;
    &#x2F;&#x2F;  socket(PF_INET,SOCK_STREAM,0);
    if((sock &#x3D; socket(PF_INET,SOCK_STREAM,IPPROTO_TCP)) &lt; 0)
        ERR_EXIT(&quot;socket&quot;);

    struct sockaddr_in serv_addr;
    memset(&amp;serv_addr,0,sizeof(serv_addr));
    serv_addr.sin_family &#x3D; AF_INET;
    serv_addr.sin_port &#x3D; htons(5188);
    serv_addr.sin_addr.s_addr &#x3D; inet_addr(&quot;127.0.0.1&quot;);

    if(connect(sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)) &lt; 0 )
        ERR_EXIT(&quot;connect&quot;);

    pid_t pid;
    pid &#x3D; fork();
    if(pid &lt; 0)
        ERR_EXIT(&quot;fork&quot;);

    if(pid &#x3D;&#x3D; 0)
    &#123;
        char recvbuf[1024] &#x3D; &#123;0&#125;;
        while(1)
        &#123;
            memset(recvbuf,0,sizeof(recvbuf));
            int ret &#x3D; read(sock,recvbuf,sizeof(recvbuf));
            if (ret &#x3D;&#x3D; -1)
                ERR_EXIT(&quot;read&quot;);
            else if(ret &#x3D;&#x3D; 0)
            &#123;
                printf(&quot;peer close\n&quot;);
                break;
            &#125;
            fputs(recvbuf,stdout);
        &#125;
        close(sock);
        kill(getppid(),SIGUSR1);
    &#125;
    else
    &#123;
        signal(SIGUSR1,handler);
        char sendbuf[1024] &#x3D; &#123;0&#125;;
        while(fgets(sendbuf,sizeof(sendbuf),stdin) !&#x3D; NULL)
        &#123;   
            write(sock,sendbuf,strlen(sendbuf));
            memset(sendbuf,0,sizeof(sendbuf));
        &#125;
        close(sock);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/thread/">
                                    <span class="chip bg-color">thread</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/23/Cpulsplus/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Cpulsplus">
                        
                        <span class="card-title">Cpulsplus</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            C++
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            moseairius
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Cpulsplus/">
                        <span class="chip bg-color">Cpulsplus</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/03/23/ComputerNetwork/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="ComputerNetwork">
                        
                        <span class="card-title">ComputerNetwork</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ComputerNetwork
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            moseairius
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ComputerNetwork/">
                        <span class="chip bg-color">ComputerNetwork</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">moseairius</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "3";
                    var startDate = "14";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="/null" target="_blank">桂ICP备2021002249号-1</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/Moseasirius" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:zhenhaimo@foxmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
