<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mosirius.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="thread">
<meta property="og:url" content="https://mosirius.cn/2022/03/23/thread/index.html">
<meta property="og:site_name" content="moblog">
<meta property="og:description" content="Thread">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mosirius.cn/2022/03/23/thread/image-20220305230343742.png">
<meta property="article:published_time" content="2022-03-23T11:35:14.000Z">
<meta property="article:modified_time" content="2022-04-17T15:29:39.922Z">
<meta property="article:author" content="moseairius">
<meta property="article:tag" content="thread">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mosirius.cn/2022/03/23/thread/image-20220305230343742.png">

<link rel="canonical" href="https://mosirius.cn/2022/03/23/thread/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>thread | moblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">moblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mosirius.cn/2022/03/23/thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="moseairius">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="moblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          thread
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-23 19:35:14" itemprop="dateCreated datePublished" datetime="2022-03-23T19:35:14+08:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-17 23:29:39" itemprop="dateModified" datetime="2022-04-17T23:29:39+08:00">2022-04-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Thread</p>
<span id="more"></span> 

<h1 id="“线程”的起源"><a href="#“线程”的起源" class="headerlink" title="“线程”的起源"></a>“线程”的起源</h1><p>“线程”一词于 1967 年左右被首次提出，是计算机硬件和软件发展过程中诞生的产物。</p>
<p>一台计算机所能利用的资源总是有限的，比如 CPU 在 1 秒钟之内最多执行 1 亿条指令，计算机一共有 1GB 的内存空间等等。因此，“如何提高计算机资源的利用率”是人们一直思考的问题，这个问题也一直带动着计算机硬件和软件的发展。</p>
<p>计算机诞生初期，任何安装任何操作系统和软件，只能运行机器指令，完成一些简单的数学运算。受到当时价格因素的制约，计算机并不普及，拥有者主要是政府、大型机构和公司，一台计算机往往由多个用户共同使用。计算机由专人负责操控，如果有用户想让计算机运行一段指令，必须先将指令输入到打孔卡（一种存储设备）中，然后交给计算机管理员，由计算机管理员负责将指令输入到计算机中执行。</p>
<p>随着对计算机资源利用率的要求不断提升，人们逐渐发现，计算机资源的利用率受管理员的影响非常大。例如，计算机每执行完一个任务，都要等待管理员输入下一个任务，期间很多硬件资源（比如 CPU、某些输入输出设备）都处于空闲状态。</p>
<p>为此，人们设计出了批处理操作系统，由它代替计算机管理员完成任务的切换工作。当计算机执行完某一任务时，批处理系统会自动将下一个要执行的任务输入到计算机中，缩减了任务切换所花费的时间，提高了计算机资源的利用率。</p>
<p>渐渐地人们又发现，批处理系统操控计算机执行的过程中，计算机的 CPU 资源仍经常处于空闲状态。举个例子，当执行中的程序进行 I/O 操作时，CPU 只能等待其 I/O 操作完成后继续工作，这段时间内 CPU 就处于空闲状态。</p>
<p>在批处理系统（又称单道批处理操作系统）的基础上，人们又设计出了功能更强大的多道批处理操作系统。和先前的系统相比，多道批处理系统主要有以下两点优势：</p>
<ul>
<li>它将计算机的内存分成很多区域，每个区域都可以存储一个程序；</li>
<li>当执行的程序执行 I/O 操作时，操作系统会将 CPU 资源分配给其它等待执行的程序。</li>
</ul>
<p>也就是说，多道批处理操作系统可以“同时”执行多个程序，这样的操作系统又称多任务操作系统。为了使多任务系统更高效地完成计算机资源的分配和回收，便于管理各个程序的执行过程，人们提出了“进程”的概念。</p>
<p>所谓进程，指的就是正在执行的应用程序。多任务操作系统可以控制各个进程的执行状态，例如终止某个正在执行的进程，启动某个暂停执行的进程等。操作系统负责为每个进程分配独立的内存空间和其它所需资源（例如 I/O 设备、文件等），进程执行完毕后，操作系统会将进程占用的资源全部回收。</p>
<p>早期的多任务操作系统，以进程为单位管理各个程序的运行以及计算机资源的分配和回收，进一步提高了计算机资源的利用率。但随着计算机硬、软件的发展，人们发现还可以做进一步优化，例如：</p>
<ul>
<li>操作系统将 CPU 资源从一个进程分配给另一个进程时，开销较大；</li>
<li>各个进程占用的内存空间是相互独立的，大大增加了进程间通信的实现难度；</li>
<li>一个进程可能会执行多个任务，当某个任务因 I/O 操作暂停执行时，其他任务将无法执行。</li>
</ul>
<p>在计算机软、硬件快速发展，人们计算机运行效率的要求越来越高的大背景下，“线程”应运而生。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>我们知道，一个进程指的是一个正在执行的应用程序。线程对应的英文名称为“thread”，它的功能是执行应用程序中的某个具体任务，比如一段程序、一个函数等。</p>
<p>线程和进程之间的关系，类似于工厂和工人之间的关系，进程好比是工厂，线程就如同工厂中的工人。一个工厂可以容纳多个工人，工厂负责为所有工人提供必要的资源（电力、产品原料、食堂、厕所等），所有工人共享这些资源，每个工人负责完成一项具体的任务，他们相互配合，共同保证整个工厂的平稳运行。</p>
<p>每个进程执行前，操作系统都会为其分配所需的资源，包括要执行的程序代码、数据、内存空间、文件资源等。一个进程至少包含 1 个线程，可以包含多个线程，所有线程共享进程的资源，各个线程也可以拥有属于自己的私有资源。</p>
<blockquote>
<p>进程仅负责为各个线程提供所需的资源，真正执行任务的是线程，而不是进程。</p>
</blockquote>
<p>下图描述了进程和线程之间的关系：</p>
<img src="/2022/03/23/thread/image-20220305230343742.png" class>

<p>如图所示，所有线程共享的进程资源有：</p>
<ul>
<li>代码：即应用程序的代码；</li>
<li>数据：包括全局变量、函数内的静态变量、堆空间的数据等；</li>
<li>进程空间：操作系统分配给进程的内存空间；</li>
<li>打开的文件：各个线程打开的文件资源，也可以为所有线程所共享，例如线程 A 打开的文件允许线程 B 进行读写操作。</li>
</ul>
<p>各个线程也可以拥有自己的私有资源，包括寄存器中存储的数据、线程执行所需的局部变量（函数参数）等。</p>
<h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><p>所谓多线程，即一个进程中拥有多（≥2）个线程，线程之间相互协作、共同执行一个应用程序。</p>
<p>我们通常将以“多线程”方式编写的程序称为“多线程程序”，将编写多线程程序的过程称为“多线程编程”，将拥有多个线程的进程称为“多线程进程”。</p>
<blockquote>
<p>当进程中仅包含 1 个执行程序指令的线程时，该线程又称“主线程”，这样的进程称为“单线程进程”。</p>
</blockquote>
<p>如今，很多应用程序（软件）都是多线程程序，例如 QQ 具备同时和多人聊天的能力、迅雷具备同时下载多个资源的能力、很多杀毒软件可以同时开启杀毒、清理垃圾、电脑加速等功能。</p>
<h1 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h1><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>
<h1 id="Windows线程的创建和使用"><a href="#Windows线程的创建和使用" class="headerlink" title="Windows线程的创建和使用"></a>Windows线程的创建和使用</h1><h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p>C++ 11 之后添加了新的标准线程库 <strong>std::thread</strong>，<strong>std::thread</strong> <strong>在 <thread></thread></strong> 头文件中声明，因此使用 <strong>std::thread</strong> 时需要包含 <strong>在 <thread></thread></strong> 头文件。</p>
<p>之前一些编译器使用 C++ 11 的编译参数是 <strong>-std=c++11</strong>:</p>
<pre class="line-numbers language-none"><code class="language-none">g++ -std&#x3D;c++11 test.cpp <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>std::thread</strong> 默认构造函数，创建一个空的 <strong>std::thread</strong> 执行对象。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;thread&gt;
std::thread thread_object(callable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>一个可调用对象可以是以下三个中的任何一个：</p>
<ul>
<li>函数指针</li>
<li>函数对象</li>
<li>lambda 表达式</li>
</ul>
<p>定义 callable 后，将其传递给 <strong>std::thread</strong> 构造函数 <strong>thread_object</strong>。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 演示多线程的CPP程序
&#x2F;&#x2F; 使用三个不同的可调用对象
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;
 
&#x2F;&#x2F; 一个虚拟函数
void foo(int Z)
&#123;
    for (int i &#x3D; 0; i &lt; Z; i++) &#123;
        cout &lt;&lt; &quot;线程使用函数指针作为可调用参数\n&quot;;
    &#125;
&#125;
 
&#x2F;&#x2F; 可调用对象
class thread_obj &#123;
public:
    void operator()(int x)
    &#123;
        for (int i &#x3D; 0; i &lt; x; i++)
            cout &lt;&lt; &quot;线程使用函数对象作为可调用参数\n&quot;;
    &#125;
&#125;;
 
int main()
&#123;
    cout &lt;&lt; &quot;线程 1 、2 、3 &quot;
         &quot;独立运行&quot; &lt;&lt; endl;
 
    &#x2F;&#x2F; 函数指针
    thread th1(foo, 3);
 
    &#x2F;&#x2F; 函数对象
    thread th2(thread_obj(), 3);
 
    &#x2F;&#x2F; 定义 Lambda 表达式
    auto f &#x3D; [](int x) &#123;
        for (int i &#x3D; 0; i &lt; x; i++)
            cout &lt;&lt; &quot;线程使用 lambda 表达式作为可调用参数\n&quot;;
    &#125;;
 
    &#x2F;&#x2F; 线程通过使用 lambda 表达式作为可调用的参数
    thread th3(f, 3);
 
    &#x2F;&#x2F; 等待线程完成
    
    &#x2F;&#x2F; 等待线程 t1 完成
    th1.join();
 
    &#x2F;&#x2F; 等待线程 t2 完成
    th2.join();
 
    &#x2F;&#x2F; 等待线程 t3 完成
    th3.join();
 
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">线程 1 、2 、3 独立运行
线程使用函数指针作为可调用参数
线程使用函数指针作为可调用参数
线程使用函数指针作为可调用参数
线程使用 lambda 表达式作为可调用参数
线程使用 lambda 表达式作为可调用参数
线程使用 lambda 表达式作为可调用参数
线程使用函数对象作为可调用参数
线程使用函数对象作为可调用参数
线程使用函数对象作为可调用参数

--------------------------------
Process exited after 0.02723 seconds with return value 0
请按任意键继续. . .




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>C++11 标准中，<code>&lt;thread&gt;</code>头文件提供了 thread 类（位于 std 命令空间中），专门用来完成线程的创建和使用。</p>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>一个线程可以用 thread 类的对象来表示，thread类中重载了多种构造函数，最常用的有以下两个：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1、Fn 表示线程要执行的函数，args 表示向 Fn 传递的多个参数，此构造函数支持泛型
template &lt;class Fn, class... Args&gt;
explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;... args);
&#x2F;&#x2F;2、移动构造函数
thread (thread&amp;&amp; x) noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。
explicit使用注意事项:

      explicit 关键字只能用于类内部的构造函数声明上。
      explicit 关键字作用于单个参数的构造函数。
跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).


 explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。

 google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。
　　effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>thread 类只提供了移动构造函数，未提供拷贝构造函数。这意味着，我们不能直接将一个事先定义好的 thread 对象赋值给另一个 thread 对象，但可以将临时的（匿名的）thread 对象赋值给另一个 thread 对象。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;
void threadFun1(int n) &#123;
    cout &lt;&lt; &quot;---thread1 running\n&quot;;
    cout &lt;&lt; &quot;n&#x3D;&quot; &lt;&lt; n &lt;&lt; endl;
&#125;
void threadFun2(const char * url) &#123;
    cout &lt;&lt; &quot;---thread2 running\n&quot;;
    cout &lt;&lt; &quot;url&#x3D;&quot; &lt;&lt; url &lt;&lt; endl;
&#125;
int main() &#123;
    &#x2F;&#x2F;调用第 1 种构造函数
    thread thread1(threadFun1,10);
    &#x2F;&#x2F;调用移动构造函数
    thread thread2 &#x3D; std::thread(threadFun2,&quot;http:&#x2F;&#x2F;google.com&quot;);
    &#x2F;&#x2F;阻塞主线程，等待 thread1 线程执行完毕
    thread1.join();
    &#x2F;&#x2F;阻塞主线程，等待 thread2 线程执行完毕
    thread2.join();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">---thread1 running
n&#x3D;10
---thread2 running
url&#x3D;http:&#x2F;&#x2F;google.com

--------------------------------
Process exited after 0.02249 seconds with return value 0
请按任意键继续. . .


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">---thread1 running
n&#x3D;---thread2 running
url&#x3D;http:&#x2F;&#x2F;google.com10


--------------------------------
Process exited after 0.02315 seconds with return value 0
请按任意键继续. . .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序执行结果为（不唯一）：为什么？</p>
<p>程序中，分别调用两种构造函数创建了两个线程，它们分别执行 threadFun1() 和 threadFun2() 函数。我们在主线程（main() 函数）中调用了 thread 类提供的 join() 成员函数，以 thread1.join() 为例，它的功能是阻塞主线程，直至 thread1 线程执行完毕后，主线程才能继续执行。</p>
<h4 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h4><p>除了 join() 成员函数外，thread 类还提供有很多实用的成员函数，表 1 给大家列出了几个最常用的函数：</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>get_id()</td>
<td>获取当前 thread 对象的线程 ID。</td>
</tr>
<tr>
<td>joinable()</td>
<td>判断当前线程是否支持调用 join() 成员函数。</td>
</tr>
<tr>
<td>join()</td>
<td>阻塞当前 thread 对象所在的线程，直至 thread 对象表示的线程执行完毕后，所在线程才能继续执行。</td>
</tr>
<tr>
<td>detach()</td>
<td>将当前线程从调用该函数的线程中分离出去，它们彼此独立执行。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个线程的状态。</td>
</tr>
</tbody></table>
<p>注意，每个thread 对象在调用析构函数销毁前，要么调用 join() 函数令主线程等待子线程执行完成，要么调用 detach() 函数将子线程和主线程分离，两者比选其一，否则程序可能存在以下两个问题：</p>
<ul>
<li>线程占用的资源将无法全部释放，造成内存泄漏；</li>
<li>当主线程执行完成而子线程未执行完时，程序执行将引发异常。</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;thread&gt;
&#x2F;&#x2F;#include &lt;unistd.h&gt; &#x2F;&#x2F;Linux
#include &lt;Windows.h&gt; &#x2F;&#x2F;Windows
using namespace std;
void threadFun1(int n) &#123;
&#x2F;&#x2F;    sleep(5);&#x2F;&#x2F;Linux
    Sleep(5);&#x2F;&#x2F;Windows
    cout &lt;&lt; &quot;---thread1 running\n&quot;;
    cout &lt;&lt; &quot;n&#x3D;&quot; &lt;&lt; n &lt;&lt; endl;
&#125;
void threadFun2(const char * url) &#123;
    cout &lt;&lt; &quot;---thread2 running\n&quot;;
    cout &lt;&lt; &quot;url&#x3D;&quot; &lt;&lt; url &lt;&lt; endl;
&#125;
int main() &#123;
    &#x2F;&#x2F;调用第 1 种构造函数
    thread thread1(threadFun1, 10);
    &#x2F;&#x2F;输出 thread1 线程的 ID
    cout &lt;&lt; &quot;thread1 ID:&quot; &lt;&lt; thread1.get_id() &lt;&lt; endl;
    &#x2F;&#x2F;调用移动构造函数
    thread thread2 &#x3D; std::thread(threadFun2, &quot;http:&#x2F;&#x2F;mozhenahi.com&quot;);
    &#x2F;&#x2F;输出 thread2 线程的 ID
    cout &lt;&lt; &quot;thread2 ID:&quot; &lt;&lt; thread2.get_id() &lt;&lt; endl;
    &#x2F;&#x2F;将 thread1 与主线程分离开，thread1 线程独立执行。
    thread1.detach();
    &#x2F;&#x2F;判断 thread2 线程是否可以调用 join() 函数
    if (thread2.joinable()) &#123;
        &#x2F;&#x2F;阻塞主线程，直至 thread2 线程执行完毕。
        thread2.join();
    &#125;
    cout &lt;&lt; &quot;main finished&quot; &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">thread1 ID:2
thread2 ID:3
---thread2 running
url&#x3D;http:&#x2F;&#x2F;mozhenahi.com
main finished

--------------------------------
Process exited after 0.02273 seconds with return value 0
请按任意键继续. . .


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序中创建了 2 个线程，通过调用 get_id() 成员函数分别获得了它们的线程 ID，其中 thread1 线程独立执行，thread2 线程先于主线程执行完成。通过执行结果可以看到，thread1 线程的执行结果并没有显示到屏幕上，这是因为 thread1 线程还未执行输出语句，主线程就已经执行结束（整个进程也执行结束），thread1 线程无法将执行结果输出到屏幕上。</p>
<p><code>&lt;thread&gt;</code>头文件中不仅定义了 thread 类，还提供了一个名为 this_thread 的命名空间，此空间中包含一些功能实用的函数，如表 2</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>get_id()</td>
<td>获得当前线程的 ID。</td>
</tr>
<tr>
<td>yield()</td>
<td>阻塞当前线程，直至条件成熟。</td>
</tr>
<tr>
<td>sleep_until()</td>
<td>阻塞当前线程，直至某个时间点为止。</td>
</tr>
<tr>
<td>sleep_for()</td>
<td>阻塞当前线程指定的时间（例如阻塞 5 秒）。</td>
</tr>
</tbody></table>
<h2 id="实现线程同步"><a href="#实现线程同步" class="headerlink" title="实现线程同步"></a>实现线程同步</h2><p>C++ 11 标准为解决“线程间抢夺公共资源”提供了多种方案，其中就包括我们前面讲到的互斥锁和条件变量。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>考虑到不同场景的需要，C++ 11 标准提供有多种互斥锁，比如递归互斥锁、定时互斥锁，自动“加锁”和“解锁”的互斥锁等。本节我们以普通的互斥锁为例，给大家讲解互斥锁的基本用法。</p>
<p>C++11标准规定，互斥锁用 mutex 类（位于 std 命名空间中）的对象表示，该类定义在<code>&lt;mutex&gt;</code>头文件中。mutex 类提供有 lock() 和 unlock() 成员函数，分别完成“加锁”和“解锁”功能。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;mutex&gt;          &#x2F;&#x2F; std::mutex
#include &lt;chrono&gt;         &#x2F;&#x2F; std::chrono::seconds()
#include &lt;thread&gt;
#include &lt;iostream&gt;
using namespace std;
int  n &#x3D; 0;
std::mutex mtx;           &#x2F;&#x2F; 定义一个 mutex 类对象，创建一个互斥锁
void threadFun() &#123;
    while(n&lt;10)&#123;
        &#x2F;&#x2F;对互斥锁进行“加锁”
        mtx.lock();
        n++;
        cout &lt;&lt; &quot;ID&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; n &#x3D; &quot;&lt;&lt; n &lt;&lt; endl;
        &#x2F;&#x2F;对互斥锁进行“解锁”
        mtx.unlock();
        &#x2F;&#x2F;暂停 1 秒
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;
int main()
&#123;
    thread th1(threadFun);
    thread th2(threadFun);
    th1.join();
    th2.join();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序执行结果为（不唯一）：</p>
<pre class="line-numbers language-none"><code class="language-none">ID2 n &#x3D; 1
ID3 n &#x3D; 2
ID3 n &#x3D; 3
ID2 n &#x3D; 4
ID3 n &#x3D; 5
ID2 n &#x3D; 6
ID3 n &#x3D; 7
ID2 n &#x3D; 8
ID3 n &#x3D; 9
ID2 n &#x3D; 10

--------------------------------
Process exited after 5.044 seconds with return value 0
请按任意键继续. . .




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ID2 n &#x3D; 1
ID3 n &#x3D; 2
ID2 n &#x3D; 3
ID3 n &#x3D; 4
ID2 n &#x3D; 5
ID3 n &#x3D; 6
ID2 n &#x3D; 7
ID3 n &#x3D; 8
ID3 n &#x3D; 9
ID2 n &#x3D; 10

--------------------------------
Process exited after 5.044 seconds with return value 0
请按任意键继续. . .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序中，访问公共变量 n 的线程有 2 个，为了避免它们之间竞争资源，对 threadFun() 函数中访问 n 变量的过程引入了互斥锁机制。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>C++ 11标准提供了两种表示条件变量的类，分别是 condition_variable 和 condition_variable_any，它们都定义在<code>&lt;condition_variable&gt;</code>头文件中。我们知道，为了避免线程间抢夺资源，条件变量通常和互斥锁搭配使用，condition_variable 类表示的条件变量只能和 unique_lock 类表示的互斥锁（可自行加锁和解锁）搭配使用，而 condition_variable_any 类表示的条件变量可以和任意类型的互斥锁搭配使用（例如递归互斥锁、定时互斥锁等）。</p>
<p>condition_variable_any 类的对象都表示一个条件变量，该类提供的成员函数如表 </p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>wait()</td>
<td>阻塞当前线程，等待条件成立。</td>
</tr>
<tr>
<td>wait_for()</td>
<td>阻塞当前线程的过程中，该函数会自动调用 unlock() 函数解锁互斥锁，从而令其他线程使用公共资源。当条件成立或者超过了指定的等待时间（比如 3 秒），该函数会自动调用 lock() 函数对互斥锁加锁，同时令线程继续执行。</td>
</tr>
<tr>
<td>wait_until()</td>
<td>和 wait_for() 功能类似，不同之处在于，wait_until() 函数可以设定一个具体时间点（例如 2021年4月8日 的某个具体时间），当条件成立或者等待时间超过了指定的时间点，函数会自动对互斥锁加锁，同时线程继续执行。</td>
</tr>
<tr>
<td>notify_one()</td>
<td>向其中一个正在等待的线程发送“条件成立”的信号。</td>
</tr>
<tr>
<td>notify_all()</td>
<td>向所有等待的线程发送“条件成立”的信号。</td>
</tr>
</tbody></table>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;thread&gt;             &#x2F;&#x2F; std::thread
#include &lt;mutex&gt;              &#x2F;&#x2F; std::mutex, std::unique_lock
#include &lt;condition_variable&gt; &#x2F;&#x2F; std::condition_variable_any
#include &lt;chrono&gt;         &#x2F;&#x2F; std::chrono::seconds()
&#x2F;&#x2F;创建一个互斥锁
std::mutex mtx;
&#x2F;&#x2F;创建一个条件变量
std::condition_variable_any cond;
void print_id() &#123;
    mtx.lock();
    &#x2F;&#x2F;阻塞线程，直至条件成立
    cond.wait(mtx);
    std::cout &lt;&lt; &quot;----threadID &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt;&quot; run&quot; &lt;&lt; std::endl;
    &#x2F;&#x2F;等待 2 秒
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mtx.unlock();
&#125;
void go() &#123;
    std::cout &lt;&lt; &quot;go running\n&quot;;
    &#x2F;&#x2F;阻塞线程 2 秒钟
    std::this_thread::sleep_for(std::chrono::seconds(2));
    &#x2F;&#x2F;通知所有等待的线程条件成立
    cond.notify_all();
&#125;
int main()
&#123;
    &#x2F;&#x2F;创建 4 个线程执行 print_id() 函数
    std::thread threads[4];
    for (int i &#x3D; 0; i &lt; 4; ++i)
        threads[i] &#x3D; std::thread(print_id);
    &#x2F;&#x2F;创建 1 个线程执行 go() 函数
    std::thread goThread(go);
    &#x2F;&#x2F;等待所有线程执行结果后，主线程才能继续执行
    goThread.join();
    for (auto&amp; th : threads) &#123;
        th.join();
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">go running
----threadID 2 run
----threadID 4 run
----threadID 5 run
----threadID 3 run

--------------------------------
Process exited after 10.04 seconds with return value 0
请按任意键继续. . .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Windows平台，Windows API提供了对多线程的支持。前面进程和线程的概念中我们提到，一个程序至少有一个线程，这个线程称为主线程(main thread)，如果我们不显示地创建线程，那我们产的程序就是只有主线程的间线程程序。</p>
<h1 id="Linux线程的创建和使用"><a href="#Linux线程的创建和使用" class="headerlink" title="Linux线程的创建和使用"></a>Linux线程的创建和使用</h1><h2 id="lt-pthread-h-gt"><a href="#lt-pthread-h-gt" class="headerlink" title="&lt;pthread.h&gt;"></a>&lt;pthread.h&gt;</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">功能：
    创建一个线程
原型：
    <span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span>
                          <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
参数：  
    thread ： 返回线程ID
    attr ： 设置线程属性，为<span class="token constant">NULL</span>时表示使用默认属性
    start_routine ： 是个函数地址，线程启动后要执行的函数
    arg ： 传给线程启动函数的参数
返回值：
    成功 ：<span class="token number">0</span>
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    线程终止
原型：
    void pthread_exit(void *retval);
参数：  
    retval ：retval不要指向一个局部变量 
返回值：
    无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    等待线程结束
原型：
    int pthread_join(pthread_t thread, void **retval);
参数：  
    thread ：线程ID
    retval ： 它指向一个指针，指向线程的返回值
    
返回值：
    成功 ： 0
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    分离线程
原型：
    int pthread_detach(pthread_t thread);
参数：  
    thread ：线程ID
    
返回值：
    成功 ： 0
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    返回线程的ID
原型：
    int pthread_self(void);    
返回值：
    总是成功，返回调用此函数的线程ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="pthread-cancle"><a href="#pthread-cancle" class="headerlink" title="pthread_cancle"></a>pthread_cancle</h3><pre class="line-numbers language-none"><code class="language-none">功能：
    取消一个执行中的线程
原型：
    int pthread_cancel(pthread_t thread); 
参数：
    thread ： 线程ID
返回值：
    成功 ： 0
    失败 ： 返回错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h3><ul>
<li>传统的一些函数是，成功返回0， 失败返回-1，并且对全局变量errno赋值以指示错误</li>
<li>pthread函数出错时不会设置全局变量errno（而大部分其它POSIX函数会这样做）。而是将错误代码通过返回值返回</li>
<li>pthread同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthread函数的错误设置，建议通过返回值判定，因为读取返回值要比读取线程内的errno变量的开销更小</li>
</ul>
<h3 id="进程线程对比"><a href="#进程线程对比" class="headerlink" title="进程线程对比"></a>进程线程对比</h3><table>
<thead>
<tr>
<th>属性</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>pid_t</td>
<td>pthread_t</td>
</tr>
<tr>
<td>创建</td>
<td>fork</td>
<td>pthread_create</td>
</tr>
<tr>
<td>等待</td>
<td>waitpid</td>
<td>pthread_join</td>
</tr>
<tr>
<td>僵尸</td>
<td>waitpid</td>
<td>pthread_join、pthread_detach</td>
</tr>
<tr>
<td>退出（自杀）</td>
<td>exit,return</td>
<td>pthread_exit,return</td>
</tr>
<tr>
<td>他杀</td>
<td>kill</td>
<td>pthread_cancel</td>
</tr>
</tbody></table>
<h2 id="用线程实现回射客户端、服务器端"><a href="#用线程实现回射客户端、服务器端" class="headerlink" title="用线程实现回射客户端、服务器端"></a>用线程实现回射客户端、服务器端</h2><p><strong>pserver.c</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">include &lt;unistd.h&gt;
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;socket.h&gt;
#include &lt;netinet&#x2F;in.h&gt;
#include &lt;arpa&#x2F;inet.h&gt;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define ERR_EXIT(m)\
    do\
&#123;\
    perror(m);\
    exit(EXIT_FAILURE);\
&#125;while(0)


void do_service(int conn)
&#123;
    char recvbuf[1024] &#x3D; &#123;0&#125;;
    while(1)
    &#123;   
        memset(recvbuf,0,sizeof(recvbuf));
        int ret &#x3D; read(conn,recvbuf,sizeof(recvbuf));
        if(ret &#x3D;&#x3D; 0)
        &#123;
            printf(&quot;client close\n&quot;);
            break;
        &#125;
        else if(ret &#x3D;&#x3D; -1)
            ERR_EXIT(&quot;read&quot;);
        fputs(recvbuf,stdout);
        write(conn,recvbuf,ret);
    &#125;
&#125;

void* thread_routine(void *arg)
&#123;
    pthread_detach(pthread_self());

    &#x2F;&#x2F; 使用取地址的方式获取
    &#x2F;&#x2F;int conn &#x3D; *((int*)arg);
    
    &#x2F;&#x2F; 使用强制转换的方式获取
    &#x2F;&#x2F; int conn &#x3D; (int)arg;

    &#x2F;&#x2F; 使用取地址的方式获取，释放空间
    int conn &#x3D; *((int*)arg);
    free(arg);

    do_service(conn);
    printf(&quot;exit thread %lu ...\n&quot;,pthread_self());
    return NULL;
&#125;

int main(void)
&#123;
    int listenfd;
    if((listenfd &#x3D; socket(PF_INET,SOCK_STREAM,IPPROTO_TCP)) &lt; 0)
        ERR_EXIT(&quot;socket&quot;);

    struct sockaddr_in serv_addr;
    memset(&amp;serv_addr,0,sizeof(serv_addr)); 
    serv_addr.sin_family &#x3D; AF_INET;
    serv_addr.sin_port &#x3D; htons(5188);
    serv_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);
    &#x2F;&#x2F;  serv_addr.sin_addr.s_addr &#x3D; inet_addr(&quot;127.0.0.1&quot;);
    &#x2F;&#x2F;  inet_aton(&quot;127.0.0.1&quot;,&amp;serv_addr.sin_addr);

    int on &#x3D; 1;
    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,&amp;on,sizeof(on)) &lt; 0)
        ERR_EXIT(&quot;setsockopt&quot;);
    if(bind(listenfd, (struct sockaddr*)(&amp;serv_addr), sizeof(serv_addr)) &lt; 0)
        ERR_EXIT(&quot;bind&quot;);

    if(listen(listenfd, SOMAXCONN) &lt; 0)
        ERR_EXIT(&quot;listen&quot;);

    struct sockaddr_in cli_addr;
    socklen_t cli_len &#x3D; sizeof(cli_addr);
    int conn;

    while(1)
    &#123;
        if((conn &#x3D; accept(listenfd, (struct sockaddr *)(&amp;cli_addr), &amp;cli_len)) &lt; 0)
            ERR_EXIT(&quot;accept&quot;);

        printf(&quot;ip : %s port : %d\n&quot;,inet_ntoa(cli_addr.sin_addr),ntohs(cli_addr.sin_port));

        pthread_t tid;
        int ret;
        &#x2F;&#x2F; 使用这种方式存在一定的问题，因为是&amp;conn,如果accept返回后，thread_routine还没有来得及处理上一个conn，conn将被改变，导致上一次连接无法处理
        &#x2F;&#x2F; 最好不要使用指针传递，应使用值传递；
        &#x2F;&#x2F;if( (ret &#x3D; pthread_create(&amp;tid, NULL, thread_routine, (void*)&amp;conn)) !&#x3D; 0 )

        &#x2F;&#x2F;使用这种方式，将int类型装换成无类型指针，int是4个字节，指针也是4个字节；但是这种做法是不可移植的，不同的操作系统，指针所占的字节数不一样
        &#x2F;&#x2F; if( (ret &#x3D; pthread_create(&amp;tid, NULL, thread_routine, (void*)conn)) !&#x3D; 0 )

        &#x2F;&#x2F;申请一块单独的内存放conn,取出后释放掉
        int *p &#x3D; malloc(sizeof(int));
        *p &#x3D; conn; 
        if( (ret &#x3D; pthread_create(&amp;tid, NULL, thread_routine, p)) !&#x3D; 0 )
        &#123;
            fprintf(stderr, &quot;pthread_create : %s\n&quot;, strerror(ret));
            exit(EXIT_FAILURE);
        &#125;

    &#125;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>pclient.c</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;socket.h&gt;
#include &lt;netinet&#x2F;in.h&gt;
#include &lt;arpa&#x2F;inet.h&gt;
#include &lt;signal.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#define ERR_EXIT(m)\
    do\
&#123;\
    perror(m);\
    exit(EXIT_FAILURE);\
&#125;while(0)


void handler(int sig)
&#123;
    printf(&quot;recv a sig :%d\n&quot;,sig);
    exit(EXIT_SUCCESS);
&#125;

int main(void)
&#123;
    int sock;
    &#x2F;&#x2F;  socket(PF_INET,SOCK_STREAM,0);
    if((sock &#x3D; socket(PF_INET,SOCK_STREAM,IPPROTO_TCP)) &lt; 0)
        ERR_EXIT(&quot;socket&quot;);

    struct sockaddr_in serv_addr;
    memset(&amp;serv_addr,0,sizeof(serv_addr));
    serv_addr.sin_family &#x3D; AF_INET;
    serv_addr.sin_port &#x3D; htons(5188);
    serv_addr.sin_addr.s_addr &#x3D; inet_addr(&quot;127.0.0.1&quot;);

    if(connect(sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)) &lt; 0 )
        ERR_EXIT(&quot;connect&quot;);

    pid_t pid;
    pid &#x3D; fork();
    if(pid &lt; 0)
        ERR_EXIT(&quot;fork&quot;);

    if(pid &#x3D;&#x3D; 0)
    &#123;
        char recvbuf[1024] &#x3D; &#123;0&#125;;
        while(1)
        &#123;
            memset(recvbuf,0,sizeof(recvbuf));
            int ret &#x3D; read(sock,recvbuf,sizeof(recvbuf));
            if (ret &#x3D;&#x3D; -1)
                ERR_EXIT(&quot;read&quot;);
            else if(ret &#x3D;&#x3D; 0)
            &#123;
                printf(&quot;peer close\n&quot;);
                break;
            &#125;
            fputs(recvbuf,stdout);
        &#125;
        close(sock);
        kill(getppid(),SIGUSR1);
    &#125;
    else
    &#123;
        signal(SIGUSR1,handler);
        char sendbuf[1024] &#x3D; &#123;0&#125;;
        while(fgets(sendbuf,sizeof(sendbuf),stdin) !&#x3D; NULL)
        &#123;   
            write(sock,sendbuf,strlen(sendbuf));
            memset(sendbuf,0,sizeof(sendbuf));
        &#125;
        close(sock);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/thread/" rel="tag"># thread</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/23/ComputerNetwork/" rel="prev" title="ComputerNetwork">
      <i class="fa fa-chevron-left"></i> ComputerNetwork
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/23/Cpulsplus/" rel="next" title="Cpulsplus">
      Cpulsplus <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%80%9C%E7%BA%BF%E7%A8%8B%E2%80%9D%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">“线程”的起源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">什么是多线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">C++ 多线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Windows%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">Windows线程的创建和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#std-thread"><span class="nav-number">3.1.</span> <span class="nav-text">std::thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.0.2.</span> <span class="nav-text">线程的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.2.</span> <span class="nav-text">实现线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.0.2.</span> <span class="nav-text">条件变量</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">Linux线程的创建和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-pthread-h-gt"><span class="nav-number">4.1.</span> <span class="nav-text">&lt;pthread.h&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-create"><span class="nav-number">4.1.1.</span> <span class="nav-text">pthread_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-exit"><span class="nav-number">4.1.2.</span> <span class="nav-text">pthread_exit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-join"><span class="nav-number">4.1.3.</span> <span class="nav-text">pthread_join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-detach"><span class="nav-number">4.1.4.</span> <span class="nav-text">pthread_detach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-self"><span class="nav-number">4.1.5.</span> <span class="nav-text">pthread_self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cancle"><span class="nav-number">4.1.6.</span> <span class="nav-text">pthread_cancle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5"><span class="nav-number">4.1.7.</span> <span class="nav-text">错误检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">4.1.8.</span> <span class="nav-text">进程线程对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="nav-number">4.2.</span> <span class="nav-text">用线程实现回射客户端、服务器端</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">moseairius</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">moseairius</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  

</body>
</html>
