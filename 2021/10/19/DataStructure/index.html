<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="DataStructure, moblog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>DataStructure | moblog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">moblog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">moblog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/15.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">DataStructure</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/data-structure/">
                                <span class="chip bg-color">data structure</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-19
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>Data structure <span id="more"></span></p>
<p>In computer science, a data structure is a data organization, management, and storage format that enables efficient access and modification. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data, it is an algebraic structure about data.</p>
<p>Stack Queue  Array   Linked List   Tree Graph  Heap    Hash table</p>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>In computer science, a tree is a widely used abstract data type that simulates a hierarchical tree structure, with a root value and subtrees of children with a parent node, represented as a set of linked nodes.</p>
<p>A tree data structure can be defined recursively as a collection of nodes, where each node is a data structure consisting of a value and a list of references to nodes. The start of the tree is the “root node” and the reference nodes are the “children”. No reference is duplicated and none points to the root.</p>
<p>Alternatively, a tree can be defined abstractly as a whole (globally) as an ordered tree, with a value assigned to each node. Both these perspectives are useful: while a tree can be analyzed mathematically as a whole, when actually represented as a data structure it is usually represented and worked with separately by node (rather than as a set of nodes and an adjacency list of edges between nodes, as one may represent a digraph, for instance). For example, looking at a tree as a whole, one can talk about “the parent node” of a given node, but in general, as a data structure, a given node only contains the list of its children but does not contain a reference to its parent (if any).</p>
<p>在计算机科学中，<strong>树</strong>（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点都只有有限个子节点或无子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
<li>树里面没有环路(cycle)</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li>
<li><strong>高度</strong>：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</li>
<li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ol>
<h2 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h2><ul>
<li><p>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。</p>
</li>
<li><p>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；</p>
<ul>
<li><p>二叉树</p>
<p>：每个节点最多含有两个子树的树称为二叉树；</p>
<ul>
<li><p>完全二叉树</p>
<p>：对于一棵二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p>
<ul>
<li>满二叉树：所有叶节点都在最底层的完全二叉树；</li>
</ul>
</li>
<li><p>平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</p>
</li>
<li><p>排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树、二分搜索树；</p>
<ul>
<li><p>平衡二叉搜索树（英语：Balanced Binary Search Tree）是一种结构平衡的二叉搜索树，它是一种每个节点的左右两子树高度差都不超过一的二叉树。它能在O(内完成插入、查找和删除操作，最早被发明的平衡二叉搜索树为AVL树。</p>
</li>
<li><p>常见的平衡二叉搜索树有：</p>
<p>AVL树<br>红黑树</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p>
</li>
<li><p>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</p>
</li>
</ul>
</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="二分搜索树的前中后序遍历"><a href="#二分搜索树的前中后序遍历" class="headerlink" title="二分搜索树的前中后序遍历"></a>二分搜索树的前中后序遍历</h2><p>关键  递归  递归顺序都是一样的，递归中一个根节点有三次接触机会，根节点的输出的时机不同</p>
<p>遍历方式的命名 如果把左节点和右节点的位置固定不动，那么根节点放在左节点的左边，称为前序（pre-order）、根节点放在左节点和右节点的中间，称为中序（in-order）、根节点放在右节点的右边，称为后序（post-order）。</p>
<p><strong>前序遍历 Pre-Order Traversal</strong>(先根遍历 先序遍历)   </p>
<p> 根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>先访问当前节点，再依次递归访问左右子树</p>
<div style="width:50%;margin:auto"><img src="/2021/10/19/DataStructure/Sorted_binary_tree_preorder.png" class> </div>

<p>前序遍历：F, B, A, D, C, E, G, I, H.</p>
<p><strong>中序遍历 In-Order Traversal</strong>  </p>
<p> 左子树—&gt; 根结点 —&gt; 右子树</p>
<p>先递归访问左子树，再访问自身，再递归访问右子树</p>
<p>结果按从小到大输出</p>
<div style="width:50%;margin:auto"><img src="/2021/10/19/DataStructure/Sorted_binary_tree_inorder.png" class> </div>



<p> 中序遍历：A, B, C, D, E, F, G, H, I.</p>
<p><strong>后序遍历 Post-Order Traversal</strong> </p>
<p>左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>先递归访问左右子树，再访问自身节点</p>
<p>左右子树都输出完在输出自身节点</p>
<div style="width:50%;margin:auto"> <img src="/2021/10/19/DataStructure/Sorted_binary_tree_postorder.png" class></div>

<p>后序遍历：A, C, E, D, B, H, I, G, F.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;

using namespace std;

&#x2F;&#x2F; 二分搜索树
template &lt;typename Key, typename Value&gt;
class BST&#123;

private:
    &#x2F;&#x2F; 树中的节点为私有的结构体, 外界不需要了解二分搜索树节点的具体实现
    struct Node&#123;
        Key key;
        Value value;
        Node *left;
        Node *right;

        Node(Key key, Value value)&#123;
            this-&gt;key &#x3D; key;
            this-&gt;value &#x3D; value;
            this-&gt;left &#x3D; this-&gt;right &#x3D; NULL;
        &#125;
    &#125;;

    Node *root; &#x2F;&#x2F; 根节点
    int count;  &#x2F;&#x2F; 树中的节点个数

public:
    &#x2F;&#x2F; 构造函数, 默认构造一棵空二分搜索树
    BST()&#123;
        root &#x3D; NULL;
        count &#x3D; 0;
    &#125;

    &#x2F;&#x2F; 析构函数, 释放二分搜索树的所有空间
    ~BST()&#123;
        destroy( root );
    &#125;

    &#x2F;&#x2F; 返回二分搜索树的节点个数
    int size()&#123;
        return count;
    &#125;

    &#x2F;&#x2F; 返回二分搜索树是否为空
    bool isEmpty()&#123;
        return count &#x3D;&#x3D; 0;
    &#125;

    &#x2F;&#x2F; 向二分搜索树中插入一个新的(key, value)数据对
    void insert(Key key, Value value)&#123;
        root &#x3D; insert(root, key, value);
    &#125;

    &#x2F;&#x2F; 查看二分搜索树中是否存在键key
    bool contain(Key key)&#123;
        return contain(root, key);
    &#125;

    &#x2F;&#x2F; 在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL
    Value* search(Key key)&#123;
        return search( root , key );
    &#125;

    &#x2F;&#x2F; 二分搜索树的前序遍历
    void preOrder()&#123;
        preOrder(root);
    &#125;

    &#x2F;&#x2F; 二分搜索树的中序遍历
    void inOrder()&#123;
        inOrder(root);
    &#125;

    &#x2F;&#x2F; 二分搜索树的后序遍历
    void postOrder()&#123;
        postOrder(root);
    &#125;

private:
    &#x2F;&#x2F; 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法
    &#x2F;&#x2F; 返回插入新节点后的二分搜索树的根
    Node* insert(Node *node, Key key, Value value)&#123;

        if( node &#x3D;&#x3D; NULL )&#123;
            count ++;
            return new Node(key, value);
        &#125;

        if( key &#x3D;&#x3D; node-&gt;key )
            node-&gt;value &#x3D; value;
        else if( key &lt; node-&gt;key )
            node-&gt;left &#x3D; insert( node-&gt;left , key, value);
        else    &#x2F;&#x2F; key &gt; node-&gt;key
            node-&gt;right &#x3D; insert( node-&gt;right, key, value);

        return node;
    &#125;

    &#x2F;&#x2F; 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法
    bool contain(Node* node, Key key)&#123;

        if( node &#x3D;&#x3D; NULL )
            return false;

        if( key &#x3D;&#x3D; node-&gt;key )
            return true;
        else if( key &lt; node-&gt;key )
            return contain( node-&gt;left , key );
        else &#x2F;&#x2F; key &gt; node-&gt;key
            return contain( node-&gt;right , key );
    &#125;

    &#x2F;&#x2F; 在以node为根的二分搜索树中查找key所对应的value, 递归算法
    &#x2F;&#x2F; 若value不存在, 则返回NULL
    Value* search(Node* node, Key key)&#123;

        if( node &#x3D;&#x3D; NULL )
            return NULL;

        if( key &#x3D;&#x3D; node-&gt;key )
            return &amp;(node-&gt;value);
        else if( key &lt; node-&gt;key )
            return search( node-&gt;left , key );
        else &#x2F;&#x2F; key &gt; node-&gt;key
            return search( node-&gt;right, key );
    &#125;

    &#x2F;&#x2F; 对以node为根的二叉搜索树进行前序遍历, 递归算法
    void preOrder(Node* node)&#123;

        if( node !&#x3D; NULL )&#123;
            cout&lt;&lt;node-&gt;key&lt;&lt;endl;
            preOrder(node-&gt;left);
            preOrder(node-&gt;right);
        &#125;
    &#125;

    &#x2F;&#x2F; 对以node为根的二叉搜索树进行中序遍历, 递归算法
    void inOrder(Node* node)&#123;

        if( node !&#x3D; NULL )&#123;
            inOrder(node-&gt;left);
            cout&lt;&lt;node-&gt;key&lt;&lt;endl;
            inOrder(node-&gt;right);
        &#125;
    &#125;

    &#x2F;&#x2F; 对以node为根的二叉搜索树进行后序遍历, 递归算法
    void postOrder(Node* node)&#123;

        if( node !&#x3D; NULL )&#123;
            postOrder(node-&gt;left);
            postOrder(node-&gt;right);
            cout&lt;&lt;node-&gt;key&lt;&lt;endl;
        &#125;
    &#125;

    &#x2F;&#x2F; 释放以node为根的二分搜索树的所有节点
    &#x2F;&#x2F; 采用后续遍历的递归算法
    void destroy(Node* node)&#123;

        if( node !&#x3D; NULL )&#123;
            destroy( node-&gt;left );
            destroy( node-&gt;right );

            delete node;
            count --;
        &#125;
    &#125;
&#125;;


&#x2F;&#x2F; 测试二分搜索树的前中后序遍历
int main() &#123;

    srand(time(NULL));
    BST&lt;int,int&gt; bst &#x3D; BST&lt;int,int&gt;();

    &#x2F;&#x2F; 取n个取值范围在[0...m)的随机整数放进二分搜索树中
    int N &#x3D; 10;
    int M &#x3D; 100;
    for( int i &#x3D; 0 ; i &lt; N ; i ++ )&#123;
        int key &#x3D; rand()%M;
        &#x2F;&#x2F; 为了后续测试方便,这里value值取和key值一样
        int value &#x3D; key;
        cout&lt;&lt;key&lt;&lt;&quot; &quot;;
        bst.insert(key,value);
    &#125;
    cout&lt;&lt;endl;

    &#x2F;&#x2F; 测试二分搜索树的size()
    cout&lt;&lt;&quot;size: &quot;&lt;&lt;bst.size()&lt;&lt;endl&lt;&lt;endl;

    &#x2F;&#x2F; 测试二分搜索树的前序遍历 preOrder
    cout&lt;&lt;&quot;preOrder: &quot;&lt;&lt;endl;
    bst.preOrder();
    cout&lt;&lt;endl;

    &#x2F;&#x2F; 测试二分搜索树的中序遍历 inOrder
    cout&lt;&lt;&quot;inOrder: &quot;&lt;&lt;endl;
    bst.inOrder();
    cout&lt;&lt;endl;

    &#x2F;&#x2F; 测试二分搜索树的后序遍历 postOrder
    cout&lt;&lt;&quot;postOrder: &quot;&lt;&lt;endl;
    bst.postOrder();
    cout&lt;&lt;endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="AVL树-（对二分搜索树的改进）"><a href="#AVL树-（对二分搜索树的改进）" class="headerlink" title="AVL树 （对二分搜索树的改进）"></a>AVL树 （对二分搜索树的改进）</h2><p>维基百科</p>
<p>AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是（logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p>
<p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
<p>百度百科</p>
<p>在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。<br>AVL树本质上还是一棵二叉搜索树，它的特点是：<br>1.本身首先是一棵二叉搜索树。<br>2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。<br>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。</p>
<p>总的来说，AVL树是对二叉搜索树的一种改进，是一种自平衡的二叉搜索树。在二叉树搜索树插入的时候，如果不平衡会自动进行调整，使二叉搜索树平衡（每个结点的左右子树的高度之差的绝对值最多为1）</p>
<p><strong>操作</strong></p>
<p>AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的”AVL旋转”。</p>
<p>以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是每个节点都带有<em>颜色</em>属性的[二叉查找树]，颜色为<em>红色</em>或<em>黑色</em>。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有[简单路径]都包含相同数目的黑色节点。</li>
</ol>
<p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p>口诀：左根右，根叶黑，不红红，黑路同。</p>
<p><strong>红黑树的特性</strong>:<br><strong>（1）每个节点或者是黑色，或者是红色。</strong><br><strong>（2）根节点是黑色。</strong><br><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong><br><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br><strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p>
<p><strong>注意</strong>：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p>红黑树示意图如下：</p>
<img src="/2021/10/19/DataStructure/RBT.png" class>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。<br>对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)==f(k2)，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。<br>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p>
<p>散列表（hash table)又称为哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关</p>
<p>如何建立 关键字与存储地址的联系</p>
<p>通过 散列函数 哈希函数 addr = H(key)</p>
<p>散列函数 H(key) = key%13</p>
<p>处理冲突的方法</p>
<p>拉链法 链接法 链地址法  把所有 同义词存储在一个链表中</p>
<h2 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集 Union Find"></a>并查集 Union Find</h2><p> <strong>连接问题</strong></p>
<p>网络中节点间的连接状态</p>
<p>网络是个抽象的概念：用户之间形成的网络</p>
<p>数学中的集合类实现</p>
<p>并查集 的并就是数学集合中的并</p>
<p>连接问题和路径问题</p>
<p>比路径问题要回答的问题少</p>
<p>1.和二分查找作比较</p>
<p>2.和select作比较</p>
<p>3.和堆作比较</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>对于一组数据，主要支持两个动作</p>
<p>union(p,q)</p>
<p>find(p)</p>
<p>用来回答一个问题 isConnected(p,q)  连接问题</p>
<h3 id="并查集的一种实现思路Quick-Find"><a href="#并查集的一种实现思路Quick-Find" class="headerlink" title="并查集的一种实现思路Quick Find"></a>并查集的一种实现思路Quick Find</h3><p>并查集的基本数据表示 数组</p>
<table>
<thead>
<tr>
<th>Id（数组下标）</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>Id[i]</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>比如，0到4对应的值为0,它们之间是相互连接的。5到9对应的值为1，它们是相互连接的。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 查找过程, 查找元素p所对应的集合编号
int find(int p) &#123;
    assert(p &gt;&#x3D; 0 &amp;&amp; p &lt;&#x3D; count);
    return id[p];
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 查看元素p和元素q是否所属一个集合
&#x2F;&#x2F; O(1)复杂度
bool isConnected(int p, int q) &#123;
    return find(p) &#x3D;&#x3D; find(q);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 合并元素p和元素q所属的集合
&#x2F;&#x2F; O(n) 复杂度
void unionSet(int p, int q) &#123;
     int pId &#x3D; find(p);
     int qId &#x3D; find(q);
     if (pId &#x3D;&#x3D; qId)
          return;
&#x2F;&#x2F; 合并过程需要遍历一遍所有元素, 将两个元素的所属集合编号合并，就是合并两个集合
      for (int i &#x3D; 0; i &lt; count; i++) &#123;
          if (id[i] &#x3D;&#x3D; pId)
               id[i] &#x3D; qId;
           &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="并查集的另外一种实现思路Quick-Union"><a href="#并查集的另外一种实现思路Quick-Union" class="headerlink" title="并查集的另外一种实现思路Quick Union"></a>并查集的另外一种实现思路Quick Union</h3><p>将每一个元素，看做是一个节点</p>
<img src="/2021/10/19/DataStructure/UnionFind1.png" class>

<p>连接的时候，使用一个根指向另有一个根</p>
<img src="/2021/10/19/DataStructure/UnionFind2.png" class>



<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int p) &#123;
    assert(p &gt;&#x3D; 0 &amp;&amp; p &lt;&#x3D; count);
    while (p !&#x3D; parent[p])
        p &#x3D; parent[p];
    return p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool isConnected(int p, int q) &#123;
    return find(p) &#x3D;&#x3D; find(q);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void unionSet(int p, int q) &#123;
    int pRoot &#x3D; find(p);
    int qRoot &#x3D; find(q);
    if (pRoot &#x3D;&#x3D; qRoot)
        return;
    parent[pRoot] &#x3D; qRoot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>完整实现</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;
&#x2F;&#x2F; Created by mo on 2021&#x2F;7&#x2F;29.
&#x2F;&#x2F;

#ifndef UNIONFIND_UNIONFIND_H
#define UNIONFIND_UNIONFIND_H

#include &lt;iostream&gt;
#include &lt;cassert&gt;

using namespace std;
&#x2F;&#x2F;第一版Union-Find
namespace UF1 &#123;
    class UnionFind &#123;

    private:
        int *id;&#x2F;&#x2F;Union-Find本质就是一个数组
        int count; &#x2F;&#x2F; 数据个数
    public:
        &#x2F;&#x2F; 构造函数
        UnionFind(int n) &#123;
            count &#x3D; n;
            id &#x3D; new int[n];
            &#x2F;&#x2F; 初始化, 每一个id[i]指向自己, 没有合并的元素
            for (int i &#x3D; 0; i &lt; n; i++)
                id[i] &#x3D; i;
        &#125;
        &#x2F;&#x2F;析构函数
        ~UnionFind() &#123;
            delete[] id;
        &#125;
        &#x2F;&#x2F; 查找过程, 查找元素p所对应的集合编号
        int find(int p) &#123;
            assert(p &gt;&#x3D; 0 &amp;&amp; p &lt;&#x3D; count);
            return id[p];
        &#125;
        &#x2F;&#x2F; 查看元素p和元素q是否所属一个集合
        &#x2F;&#x2F; O(1)复杂度
        bool isConnected(int p, int q) &#123;
            return find(p) &#x3D;&#x3D; find(q);
        &#125;
        &#x2F;&#x2F; 合并元素p和元素q所属的集合
        &#x2F;&#x2F; O(n) 复杂度
        void unionSet(int p, int q) &#123;
            int pId &#x3D; find(p);
            int qId &#x3D; find(q);
            if (pId &#x3D;&#x3D; qId)
                return;
            &#x2F;&#x2F; 合并过程需要遍历一遍所有元素, 将两个元素的所属集合编号合并，就是合并两个集合
            for (int i &#x3D; 0; i &lt; count; i++) &#123;
                if (id[i] &#x3D;&#x3D; pId)
                    id[i] &#x3D; qId;
            &#125;
        &#125;
    &#125;;
&#125;
&#x2F;&#x2F;第二版Union-Find
namespace UF2 &#123;
    class UnionFind &#123;
    private:
        int *parent;
        int count;

    public:
        UnionFind(int count) &#123;
            parent &#x3D; new int[count];
            this-&gt;count &#x3D; count;
            for (int i &#x3D; 0; i &lt; count; i++) &#123;
                parent[i] &#x3D; i;
            &#125;
        &#125;

        ~UnionFind() &#123;
            delete[] parent;
        &#125;

        int find(int p) &#123;
            assert(p &gt;&#x3D; 0 &amp;&amp; p &lt;&#x3D; count);
            while (p !&#x3D; parent[p])
                p &#x3D; parent[p];
            return p;
        &#125;

        bool isConnected(int p, int q) &#123;
            return find(p) &#x3D;&#x3D; find(q);
        &#125;

        void unionSet(int p, int q) &#123;
            int pRoot &#x3D; find(p);
            int qRoot &#x3D; find(q);
            if (pRoot &#x3D;&#x3D; qRoot)
                return;
            parent[pRoot] &#x3D; qRoot;
        &#125;
    &#125;;
&#125;
&#x2F;&#x2F;第三版Union-Find
namespace UF3 &#123;
    class UnionFind &#123;
    private:
        int *parent; &#x2F;&#x2F; parent[i]表示第i个元素所指向的父节点
        int *sz;&#x2F;&#x2F; sz[i]表示以i为根的集合中元素个数
        int count;&#x2F;&#x2F; 数据个数
    public:
        &#x2F;&#x2F;构造函数
        UnionFind(int count) &#123;
            parent &#x3D; new int[count];
            sz &#x3D; new int[count];
            this-&gt;count &#x3D; count;
            for (int i &#x3D; 0; i &lt; count; i++) &#123;
                parent[i] &#x3D; i;
                sz[i] &#x3D; 1;
            &#125;
        &#125;
        &#x2F;&#x2F;析构函数
        ~UnionFind() &#123;
            delete[] parent;
            delete[] sz;
        &#125;
        &#x2F;&#x2F; 查找过程, 查找元素p所对应的集合编号
        &#x2F;&#x2F; O(h)复杂度, h为树的高度
        int find(int p) &#123;
            assert(p &gt;&#x3D; 0 &amp;&amp; p &lt;&#x3D; count);
            &#x2F;&#x2F; 不断去查询自己的父亲节点, 直到到达根节点
            &#x2F;&#x2F; 根节点的特点: parent[p] &#x3D;&#x3D; p
            while (p !&#x3D; parent[p]) &#123;
                p &#x3D; parent[p];
            &#125;
            return p;
        &#125;

        &#x2F;&#x2F; 查看元素p和元素q是否所属一个集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度
        bool isConnected(int p, int q) &#123;
            return find(p) &#x3D;&#x3D; find(q);
        &#125;

        &#x2F;&#x2F; 合并元素p和元素q所属的集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度
        void unionSet(int p, int q) &#123;
            int pRoot &#x3D; find(p);
            int qRoot &#x3D; find(q);

            if (pRoot &#x3D;&#x3D; qRoot)
                return;
            &#x2F;&#x2F; 根据两个元素所在树的元素个数不同判断合并方向
            &#x2F;&#x2F; 将元素个数少的集合合并到元素个数多的集合上
            if (sz[pRoot] &lt; sz[qRoot]) &#123;
                parent[pRoot] &#x3D; qRoot;
                sz[qRoot] +&#x3D; sz[pRoot];
            &#125; else &#123;
                parent[qRoot] &#x3D; pRoot;
                sz[pRoot] +&#x3D; sz[qRoot];
            &#125;
        &#125;
    &#125;;
&#125;
&#x2F;&#x2F;第四版Union-Find
namespace UF4 &#123;
    class UnionFind &#123;
    private:
        int *rank; &#x2F;&#x2F; rank[i]表示以i为根的集合所表示的树的层数
        int *parent;&#x2F;&#x2F; parent[i]表示第i个元素所指向的父节点
        int count; &#x2F;&#x2F; 数据个数
    public:
        &#x2F;&#x2F;构造函数
        UnionFind(int count) &#123;
            parent &#x3D; new int[count];
            rank &#x3D; new int[count];
            this-&gt;count &#x3D; count;
            for (int i &#x3D; 0; i &lt; count; i++) &#123;
                parent[i] &#x3D; i;
                rank[i] &#x3D; 1;
            &#125;
        &#125;
        ~UnionFind() &#123;
            delete[] parent;
            delete[] rank;
        &#125;

        int find(int p) &#123;
            assert(p &gt;&#x3D; 0 &amp;&amp; p &lt;&#x3D; count);
            &#x2F;&#x2F; 不断去查询自己的父亲节点, 直到到达根节点
            &#x2F;&#x2F; 根节点的特点: parent[p] &#x3D;&#x3D; p
            while (p !&#x3D; parent[p]) &#123;
                p &#x3D; parent[p];
            &#125;
            return p;
        &#125;

        &#x2F;&#x2F; 查看元素p和元素q是否所属一个集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度
        bool isConnected(int p, int q) &#123;
            return find(p) &#x3D;&#x3D; find(q);
        &#125;
        &#x2F;&#x2F; 合并元素p和元素q所属的集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度

        void unionSet(int p, int q) &#123;

            int pRoot &#x3D; find(p);
            int qRoot &#x3D; find(q);

            if (pRoot &#x3D;&#x3D; qRoot)
                return;
            &#x2F;&#x2F; 根据两个元素所在树的元素个数不同判断合并方向
            &#x2F;&#x2F; 将元素个数少的集合合并到元素个数多的集合上
            if (rank[pRoot] &lt; rank[qRoot]) &#123;
                parent[pRoot] &#x3D; qRoot;
            &#125; else if (rank[pRoot] &gt; rank[qRoot]) &#123;
                parent[qRoot] &#x3D; pRoot;
            &#125; else &#123;&#x2F;&#x2F; rank[pRoot] &#x3D;&#x3D; rank[qRoot]
                parent[pRoot] &#x3D; qRoot;
                rank[qRoot] +&#x3D; 1;   &#x2F;&#x2F; 此时, 我维护rank的值
            &#125;
        &#125;
    &#125;;
&#125;
namespace UF5 &#123;
    &#x2F;&#x2F; rank[i]表示以i为根的集合所表示的树的层数
    &#x2F;&#x2F; 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值
    &#x2F;&#x2F; 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准
    class UnionFind &#123;

    public: &#x2F;&#x2F; 后续, 我们要在外部操控并查集的数据, 在这里使用public
        int *parent; &#x2F;&#x2F; parent[i]表示第i个元素所指向的父节点

    private:
        int *rank; &#x2F;&#x2F; rank[i]表示以i为根的集合所表示的树的层数
&#x2F;&#x2F;        int* parent;&#x2F;&#x2F; parent[i]表示第i个元素所指向的父节点
        int count; &#x2F;&#x2F; 数据个数
    public:
        &#x2F;&#x2F;构造函数
        UnionFind(int count) &#123;
            parent &#x3D; new int[count];
            rank &#x3D; new int[count];
            this-&gt;count &#x3D; count;
            for (int i &#x3D; 0; i &lt; count; i++) &#123;
                parent[i] &#x3D; i;
                rank[i] &#x3D; 1;
            &#125;
        &#125;

        ~UnionFind() &#123;
            delete[] parent;
            delete[] rank;
        &#125;

        int find(int p) &#123;
            assert(p &gt;&#x3D; 0 &amp;&amp; p &lt; count);
            &#x2F;&#x2F; 不断去查询自己的父亲节点, 直到到达根节点
            &#x2F;&#x2F; 根节点的特点: parent[p] &#x3D;&#x3D; p

            &#x2F;&#x2F; path compression 1
            while (p !&#x3D; parent[p]) &#123;
                parent[p] &#x3D; parent[parent[p]];
                p &#x3D; parent[p];
            &#125;
            return p;

            &#x2F;&#x2F; path compression 2, 递归算法
&#x2F;&#x2F;            if (p !&#x3D; parent[p])&#123;
&#x2F;&#x2F;                parent[p] &#x3D; find(parent[p]);
&#x2F;&#x2F;            &#125;
&#x2F;&#x2F;            return parent[p];
        &#125;

        &#x2F;&#x2F; 查看元素p和元素q是否所属一个集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度
        bool isConnected(int p, int q) &#123;
            return find(p) &#x3D;&#x3D; find(q);
        &#125;
        &#x2F;&#x2F; 合并元素p和元素q所属的集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度

        void unionSet(int p, int q) &#123;

            int pRoot &#x3D; find(p);
            int qRoot &#x3D; find(q);

            if (pRoot &#x3D;&#x3D; qRoot)
                return;
            &#x2F;&#x2F; 根据两个元素所在树的元素个数不同判断合并方向
            &#x2F;&#x2F; 将元素个数少的集合合并到元素个数多的集合上
            if (rank[pRoot] &lt; rank[qRoot]) &#123;
                parent[pRoot] &#x3D; qRoot;
            &#125; else if (rank[pRoot] &gt; rank[qRoot]) &#123;
                parent[qRoot] &#x3D; pRoot;
            &#125; else &#123;&#x2F;&#x2F; rank[pRoot] &#x3D;&#x3D; rank[qRoot]
                parent[pRoot] &#x3D; qRoot;
                rank[qRoot] +&#x3D; 1;   &#x2F;&#x2F; 此时, 我维护rank的值
            &#125;
        &#125;

        &#x2F;&#x2F; 打印输出并查集中的parent数据
        void show() &#123;
            for (int i &#x3D; 0; i &lt; count; i++)
                cout &lt;&lt; parent[i] &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
        &#125;
    &#125;;
&#125;
namespace UF6 &#123;
    &#x2F;&#x2F; rank[i]表示以i为根的集合所表示的树的层数
    &#x2F;&#x2F; 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值
    &#x2F;&#x2F; 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准
    class UnionFind &#123;

    public: &#x2F;&#x2F; 后续, 我们要在外部操控并查集的数据, 在这里使用public
        int *parent; &#x2F;&#x2F; parent[i]表示第i个元素所指向的父节点

    private:
        int *rank; &#x2F;&#x2F; rank[i]表示以i为根的集合所表示的树的层数
&#x2F;&#x2F;        int* parent;&#x2F;&#x2F; parent[i]表示第i个元素所指向的父节点
        int count; &#x2F;&#x2F; 数据个数
    public:
        &#x2F;&#x2F;构造函数
        UnionFind(int count) &#123;
            parent &#x3D; new int[count];
            rank &#x3D; new int[count];
            this-&gt;count &#x3D; count;
            for (int i &#x3D; 0; i &lt; count; i++) &#123;
                parent[i] &#x3D; i;
                rank[i] &#x3D; 1;
            &#125;
        &#125;

        ~UnionFind() &#123;
            delete[] parent;
            delete[] rank;
        &#125;

        int find(int p) &#123;
            assert(p &gt;&#x3D; 0 &amp;&amp; p &lt; count);
            &#x2F;&#x2F; 不断去查询自己的父亲节点, 直到到达根节点
            &#x2F;&#x2F; 根节点的特点: parent[p] &#x3D;&#x3D; p

            &#x2F;&#x2F; path compression 1
&#x2F;&#x2F;            while(p !&#x3D; parent[p])&#123;
&#x2F;&#x2F;                parent[p] &#x3D; parent[parent[p]];
&#x2F;&#x2F;                p &#x3D; parent[p];
&#x2F;&#x2F;            &#125;
&#x2F;&#x2F;            return p;

            &#x2F;&#x2F; path compression 2, 递归算法
            if (p !&#x3D; parent[p]) &#123;
                parent[p] &#x3D; find(parent[p]);
            &#125;
            return parent[p];
        &#125;

        &#x2F;&#x2F; 查看元素p和元素q是否所属一个集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度
        bool isConnected(int p, int q) &#123;
            return find(p) &#x3D;&#x3D; find(q);
        &#125;
        &#x2F;&#x2F; 合并元素p和元素q所属的集合
        &#x2F;&#x2F; O(h)复杂度, h为树的高度

        void unionSet(int p, int q) &#123;

            int pRoot &#x3D; find(p);
            int qRoot &#x3D; find(q);

            if (pRoot &#x3D;&#x3D; qRoot)
                return;
            &#x2F;&#x2F; 根据两个元素所在树的元素个数不同判断合并方向
            &#x2F;&#x2F; 将元素个数少的集合合并到元素个数多的集合上
            if (rank[pRoot] &lt; rank[qRoot]) &#123;
                parent[pRoot] &#x3D; qRoot;
            &#125; else if (rank[pRoot] &gt; rank[qRoot]) &#123;
                parent[qRoot] &#x3D; pRoot;
            &#125; else &#123;&#x2F;&#x2F; rank[pRoot] &#x3D;&#x3D; rank[qRoot]
                parent[pRoot] &#x3D; qRoot;
                rank[qRoot] +&#x3D; 1;   &#x2F;&#x2F; 此时, 我维护rank的值
            &#125;
        &#125;

        &#x2F;&#x2F; 打印输出并查集中的parent数据
        void show() &#123;
            for (int i &#x3D; 0; i &lt; count; i++)
                cout &lt;&lt; parent[i] &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
        &#125;
    &#125;;

&#125;
#endif &#x2F;&#x2F;UNIONFIND_UNIONFIND_H
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;
&#x2F;&#x2F; Created by mozhenhai on 2021&#x2F;7&#x2F;30.
&#x2F;&#x2F;

#ifndef UNIONFIND_UNIONFINDTESTHELPER_H
#define UNIONFIND_UNIONFINDTESTHELPER_H

#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;vector&gt;
#include &quot;UnionFind.h&quot;

using namespace std;

&#x2F;&#x2F; 测试并查集的辅助函数

namespace UnionFindTestHelper &#123;
    &#x2F;&#x2F; 测试第一版本的并查集, 测试元素个数为n
    void testUF1(int n) &#123;

        srand(time(NULL));
        UF1::UnionFind uf &#x3D; UF1::UnionFind(n);
        time_t startTime &#x3D; clock();
        &#x2F;&#x2F; 进行n次操作, 每次随机选择两个元素进行合并操作
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.unionSet(a, b);
        &#125;
        &#x2F;&#x2F; 再进行n次操作, 每次随机选择两个元素, 查询他们是否同属一个集合
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.isConnected(a, b);
        &#125;
        time_t endTime &#x3D; clock();

        &#x2F;&#x2F; 打印输出对这2n个操作的耗时
        cout &lt;&lt; &quot;UF1, &quot; &lt;&lt; 2 * n &lt;&lt; &quot;  ops, &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;
    &#125;

    &#x2F;&#x2F; 测试第二版本的并查集, 测试元素个数为n
    void testUF2(int n) &#123;

        srand(time(NULL));
        UF2::UnionFind uf &#x3D; UF2::UnionFind(n);
        time_t startTime &#x3D; clock();
        &#x2F;&#x2F; 进行n次操作, 每次随机选择两个元素进行合并操作
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.unionSet(a, b);
        &#125;
        &#x2F;&#x2F; 再进行n次操作, 每次随机选择两个元素, 查询他们是否同属一个集合
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.isConnected(a, b);
        &#125;
        time_t endTime &#x3D; clock();

        &#x2F;&#x2F; 打印输出对这2n个操作的耗时
        cout &lt;&lt; &quot;UF2, &quot; &lt;&lt; 2 * n &lt;&lt; &quot;  ops, &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl;
    &#125;

    &#x2F;&#x2F; 测试第三版本的并查集, 测试元素个数为n
    void testUF3(int n) &#123;
        srand(time(NULL));
        UF3::UnionFind uf &#x3D; UF3::UnionFind(n);

        time_t startTime &#x3D; clock();

        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.unionSet(a, b);
        &#125;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.isConnected(a, b);
        &#125;
        time_t endTime &#x3D; clock();

        cout &lt;&lt; &quot;UF3, &quot; &lt;&lt; 2 * n &lt;&lt; &quot;  ops, &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;
    &#125;

    &#x2F;&#x2F; 测试第四版本的并查集, 测试元素个数为n
    void testUF4(int n) &#123;

        srand(time(NULL));
        UF4::UnionFind uf &#x3D; UF4::UnionFind(n);

        time_t startTime &#x3D; clock();

        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.unionSet(a, b);
        &#125;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.isConnected(a, b);
        &#125;
        time_t endTime &#x3D; clock();

        cout &lt;&lt; &quot;UF4, &quot; &lt;&lt; 2 * n &lt;&lt; &quot;  ops, &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;
    &#125;

    &#x2F;&#x2F; 测试第五版本的并查集, 测试元素个数为n
    void testUF5(int n) &#123;

        srand(time(NULL));
        UF5::UnionFind uf &#x3D; UF5::UnionFind(n);

        time_t startTime &#x3D; clock();

        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.unionSet(a, b);
        &#125;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.isConnected(a, b);
        &#125;
        time_t endTime &#x3D; clock();

        cout &lt;&lt; &quot;UF5, &quot; &lt;&lt; 2 * n &lt;&lt; &quot;  ops, &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;
    &#125;
    &#x2F;&#x2F; 测试第六版本的并查集, 测试元素个数为n

    void testUF6(int n) &#123;

        srand(time(NULL));
        UF6::UnionFind uf &#x3D; UF6::UnionFind(n);

        time_t startTime &#x3D; clock();

        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.unionSet(a, b);
        &#125;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int a &#x3D; rand() % n;
            int b &#x3D; rand() % n;
            uf.isConnected(a, b);
        &#125;
        time_t endTime &#x3D; clock();

        cout &lt;&lt; &quot;UF6, &quot; &lt;&lt; 2 * n &lt;&lt; &quot;  ops, &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;
    &#125;

    &#x2F;&#x2F; 使用相同的测试数据测试UF的执行效率
    template&lt;typename UF&gt;
    void testUF(const string &amp;ufName, UF &amp;uf, const vector&lt;pair&lt;int, int&gt;&gt; &amp;unionTest,
                const vector&lt;pair&lt;int, int&gt;&gt; &amp;connectTest) &#123;

        time_t startTime &#x3D; clock();
        for (int i &#x3D; 0; i &lt; unionTest.size(); i++) &#123;
            int a &#x3D; unionTest[i].first;
            int b &#x3D; unionTest[i].second;
            uf.unionSet(a, b);
        &#125;
        for (int i &#x3D; 0; i &lt; connectTest.size(); i++) &#123;
            int a &#x3D; connectTest[i].first;
            int b &#x3D; connectTest[i].second;
            uf.isConnected(a, b);
        &#125;
        time_t endTime &#x3D; clock();

        cout &lt;&lt; ufName &lt;&lt; &quot; with &quot; &lt;&lt; unionTest.size() &lt;&lt; &quot; unionElements ops, &quot;;
        cout &lt;&lt; connectTest.size() &lt;&lt; &quot; isConnected ops, &quot;;
        cout &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;
    &#125;
&#125;

#endif &#x2F;&#x2F;UNIONFIND_UNIONFINDTESTHELPER_H
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;
&#x2F;&#x2F; Created by mozhenhai on 2021&#x2F;7&#x2F;30.
&#x2F;&#x2F;

#ifndef UNIONFIND_TEST_H
#define UNIONFIND_TEST_H

#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &quot;UnionFindTestHelper.h&quot;


&#x2F;&#x2F; 使用相同的测试数据测试UF的执行效率
template&lt;typename UF&gt;

void testUF(const string &amp;ufName, UF &amp;uf, const vector&lt;pair&lt;int, int&gt;&gt; &amp;unionTest,
            const vector&lt;pair&lt;int, int&gt;&gt; &amp;connectTest) &#123;

    time_t startTime &#x3D; clock();
    for (int i &#x3D; 0; i &lt; unionTest.size(); i++) &#123;
        int a &#x3D; unionTest[i].first;
        int b &#x3D; unionTest[i].second;
        uf.unionSet(a, b);
    &#125;
    for (int i &#x3D; 0; i &lt; connectTest.size(); i++) &#123;
        int a &#x3D; connectTest[i].first;
        int b &#x3D; connectTest[i].second;
        uf.isConnected(a, b);
    &#125;
    time_t endTime &#x3D; clock();

    cout &lt;&lt; ufName &lt;&lt; &quot; with &quot; &lt;&lt; unionTest.size() &lt;&lt; &quot; unionElements ops, &quot;;
    cout &lt;&lt; connectTest.size() &lt;&lt; &quot; isConnected ops, &quot;;
    cout &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;
&#125;

void testUF123456() &#123;
    &#x2F;&#x2F; 对比UF1, UF2, UF3, UF4, UF5和UF6的时间性能
    &#x2F;&#x2F; 在这里, 我们对于不同的UnionFind的实现, 使用相同的测试用例, 让测试结果更加准确

    &#x2F;&#x2F; 使用5,000,000的数据规模
    int n &#x3D; 5000000;

    srand(time(NULL));

    &#x2F;&#x2F; 生成unionElements的测试用例
    vector&lt;pair&lt;int, int&gt;&gt; unionTest;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        int a &#x3D; rand() % n;
        int b &#x3D; rand() % n;
        unionTest.push_back(make_pair(a, b));
    &#125;

    &#x2F;&#x2F; 生成isConnected的测试用例
    vector&lt;pair&lt;int, int&gt;&gt; connectTest;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        int a &#x3D; rand() % n;
        int b &#x3D; rand() % n;
        connectTest.push_back(make_pair(a, b));
    &#125;
    &#x2F;&#x2F; 测试我们的UF1 ~ UF6

    &#x2F;&#x2F; 100万数据对于UF1和UF2来说太慢了, 不再测试
&#x2F;&#x2F;    UF1::UnionFind uf1 &#x3D; UF1::UnionFind(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF(&quot;UF1&quot;, uf1, unionTest, connectTest);
&#x2F;&#x2F;
&#x2F;&#x2F;    UF2::UnionFind uf2 &#x3D; UF2::UnionFind(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF(&quot;UF2&quot;, uf2, unionTest, connectTest);

    UF3::UnionFind uf3 &#x3D; UF3::UnionFind(n);
    testUF(&quot;UF3&quot;, uf3, unionTest, connectTest);

    UF4::UnionFind uf4 &#x3D; UF4::UnionFind(n);
    testUF(&quot;UF4&quot;, uf4, unionTest, connectTest);

    UF5::UnionFind uf5 &#x3D; UF5::UnionFind(n);
    testUF(&quot;UF5&quot;, uf5, unionTest, connectTest);

    UF6::UnionFind uf6 &#x3D; UF6::UnionFind(n);
    testUF(&quot;UF6&quot;, uf6, unionTest, connectTest);
&#125;

void test() &#123;

    &#x2F;&#x2F; 使用5,000,000的数据规模
    int n &#x3D; 5000000;

    srand(time(NULL));

    &#x2F;&#x2F; 生成unionElements的测试用例
    vector&lt;pair&lt;int, int&gt;&gt; unionTest;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        int a &#x3D; rand() % n;
        int b &#x3D; rand() % n;
        unionTest.push_back(make_pair(a, b));
    &#125;

    &#x2F;&#x2F; 生成isConnected的测试用例
    vector&lt;pair&lt;int, int&gt;&gt; connectTest;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        int a &#x3D; rand() % n;
        int b &#x3D; rand() % n;
        connectTest.push_back(make_pair(a, b));
    &#125;

    &#x2F;&#x2F; 测试我们的UF1 ~ UF6

    &#x2F;&#x2F; 100万数据对于UF1和UF2来说太慢了, 不再测试
&#x2F;&#x2F;    UF1::UnionFind uf1 &#x3D; UF1::UnionFind(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF(&quot;UF1&quot;, uf1, unionTest, connectTest);
&#x2F;&#x2F;
&#x2F;&#x2F;    UF2::UnionFind uf2 &#x3D; UF2::UnionFind(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF(&quot;UF2&quot;, uf2, unionTest, connectTest);

    UF3::UnionFind uf3 &#x3D; UF3::UnionFind(n);
    UnionFindTestHelper::testUF(&quot;UF3&quot;, uf3, unionTest, connectTest);

    UF4::UnionFind uf4 &#x3D; UF4::UnionFind(n);
    UnionFindTestHelper::testUF(&quot;UF4&quot;, uf4, unionTest, connectTest);

    UF5::UnionFind uf5 &#x3D; UF5::UnionFind(n);
    UnionFindTestHelper::testUF(&quot;UF5&quot;, uf5, unionTest, connectTest);

    UF6::UnionFind uf6 &#x3D; UF6::UnionFind(n);
    UnionFindTestHelper::testUF(&quot;UF6&quot;, uf6, unionTest, connectTest);
&#125;

void testUF56() &#123;

    &#x2F;&#x2F; 为了能够方便地看出两种路径压缩算法的不同,我们只使用有5个元素的并查集进行试验
    int n &#x3D; 5;

    UF5::UnionFind uf5 &#x3D; UF5::UnionFind(n);
    UF6::UnionFind uf6 &#x3D; UF6::UnionFind(n);

    &#x2F;&#x2F; 我们将我们的并查集初始设置成如下的样子
    &#x2F;&#x2F;            0
    &#x2F;&#x2F;           &#x2F;
    &#x2F;&#x2F;          1
    &#x2F;&#x2F;         &#x2F;
    &#x2F;&#x2F;        2
    &#x2F;&#x2F;       &#x2F;
    &#x2F;&#x2F;      3
    &#x2F;&#x2F;     &#x2F;
    &#x2F;&#x2F;    4
    for (int i &#x3D; 1; i &lt; n; i++) &#123;
        uf5.parent[i] &#x3D; i - 1;
        uf6.parent[i] &#x3D; i - 1;
    &#125;

    &#x2F;&#x2F; 现在, 我们对两个并查集调用find(4)操作
    uf5.find(n - 1);
    uf6.find(n - 1);

    &#x2F;&#x2F; 通过show, 我们可以看出, 使用迭代的路径压缩, 我们的并查集变成这个样子:
    &#x2F;&#x2F;     0
    &#x2F;&#x2F;    &#x2F; \
    &#x2F;&#x2F;   1   2
    &#x2F;&#x2F;  &#x2F; \
    &#x2F;&#x2F; 3  4
    cout &lt;&lt; &quot;UF implements Path Compression by recursion:&quot; &lt;&lt; endl;
    uf5.show();

    cout &lt;&lt; endl;

    &#x2F;&#x2F; 使用递归的路径压缩, 我们的并查集变成这个样子:
    &#x2F;&#x2F;     0
    &#x2F;&#x2F;  &#x2F; &#x2F; \ \
    &#x2F;&#x2F; 1 2   3 4
    cout &lt;&lt; &quot;UF implements Path Compression without recursion:&quot; &lt;&lt; endl;
    uf6.show();


    &#x2F;&#x2F; 大家也可以调大n的值, 看看结果的不同:)

&#125;


#endif &#x2F;&#x2F;UNIONFIND_TEST_H
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &quot;UnionFindTestHelper.h&quot;
#include &quot;test.h&quot;

int main() &#123;
    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;

&#x2F;&#x2F;    int n &#x3D; 100000;
&#x2F;&#x2F;    UnionFindTestHelper::testUF1(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF2(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF3(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF4(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF5(n);
&#x2F;&#x2F;    UnionFindTestHelper::testUF6(n);
&#x2F;&#x2F;    testUF123456();
    testUF56();


    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Heap-最大堆"><a href="#Heap-最大堆" class="headerlink" title="Heap 最大堆"></a>Heap 最大堆</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;
#include &lt;typeinfo&gt;
using namespace std;

template&lt;typename Item&gt;

class MaxHeap &#123;

private:
    Item *data;
    int count;
    int capacity;

    void shiftUp(int k) &#123;
        while (k &gt; 1 &amp;&amp; data[k &#x2F; 2] &lt; data[k])&#x2F;&#x2F;k&gt;1防止越界父节点的元素值是否小于子节点
        &#123;
            swap(data[k &#x2F; 2], data[k]);
            k &#x2F;&#x3D; 2;&#x2F;&#x2F;更新k

        &#125;
    &#125;

    void shiftDown(int k) &#123;
        &#x2F;&#x2F;判断k节点有孩子，这里判断左孩子，一棵完全二叉树中，可能只有左孩子而没有右孩子，不可能只有右孩子而没有左孩子
        while (2 * k &lt;&#x3D; count) &#123;
            int j &#x3D; 2 * k;&#x2F;&#x2F;在此轮循环中，data[k]和data[j]交换位置
            if (j + 1 &lt;&#x3D; count &amp;&amp; data[j + 1] &gt; data[j])&#x2F;&#x2F;说明有右孩子，而且右孩子的值比左孩子的值大
            &#123;
                j &#x3D; j + 1;
            &#125;
            &#x2F;&#x2F; data[j] 是 data[2*k]和data[2*k+1]中的最大值
            if (data[k] &gt;&#x3D; data[j])
                break;
            swap(data[k], data[j]);&#x2F;&#x2F;可以优化，不用每一遍都swap，可以最后再交换(插入排序优化  思想）
            k &#x3D; j;
        &#125;
    &#125;

public:
    &#x2F;&#x2F;构造函数，构造一个空堆，可容纳capacity个元素
    MaxHeap(int capacity) &#123;
        data &#x3D; new Item[capacity + 1];&#x2F;&#x2F;因为我们从数组下标索引1开始存数据
        count &#x3D; 0;
        this-&gt;capacity &#x3D; capacity;
    &#125;

    &#x2F;&#x2F;Heapify
    MaxHeap(Item array[], int n) &#123;
        data &#x3D; new Item[n + 1];
        capacity &#x3D; n;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            data[i + 1] &#x3D;&#x3D; array[i];

        &#125;
        count &#x3D; n;
        for (int i &#x3D; count &#x2F; 2; i &gt;&#x3D; 1; i--) &#123;
            shiftDown(i);
        &#125;
    &#125;

    &#x2F;&#x2F;析构函数
    ~MaxHeap() &#123;
        delete[] data;

    &#125;

    &#x2F;&#x2F;返回堆中元素的个数
    int size() &#123;
        return count;
    &#125;

    bool isEmpty() &#123;
        return count &#x3D;&#x3D; 0;
    &#125;

    void insert(Item item) &#123;
        assert(count + 1 &lt;&#x3D; capacity);
        data[count + 1] &#x3D; item;&#x2F;&#x2F;隐藏数组越界问题,可以先判断后开辟新的空间解决
        count++;
        shiftUp(count);
    &#125;

    void print() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; size(); i++) &#123;
            cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;

    Item extractMax() &#123;
        assert(count &gt; 0);
        Item ret &#x3D; data[1];
        swap(data[1], data[count]);
        count--;
        shiftDown(1);
        return ret;

    &#125;

public:
    &#x2F;&#x2F; 以树状打印整个堆结构
    void testPrint() &#123;

        &#x2F;&#x2F; 我们的testPrint只能打印100个元素以内的堆的树状信息
        if (size() &gt;&#x3D; 100) &#123;
            cout &lt;&lt; &quot;This print function can only work for less than 100 int&quot;;
            return;
        &#125;

        &#x2F;&#x2F; 我们的testPrint只能处理整数信息
        if (typeid(Item) !&#x3D; typeid(int)) &#123;
            cout &lt;&lt; &quot;This print function can only work for int item&quot;;
            return;
        &#125;

        cout &lt;&lt; &quot;The max heap size is: &quot; &lt;&lt; size() &lt;&lt; endl;
        cout &lt;&lt; &quot;Data in the max heap: &quot;;
        for (int i &#x3D; 1; i &lt;&#x3D; size(); i++) &#123;
            &#x2F;&#x2F; 我们的testPrint要求堆中的所有整数在[0, 100)的范围内
            assert(data[i] &gt;&#x3D; 0 &amp;&amp; data[i] &lt; 100);
            cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
        cout &lt;&lt; endl;

        int n &#x3D; size();
        int max_level &#x3D; 0;
        int number_per_level &#x3D; 1;
        while (n &gt; 0) &#123;
            max_level +&#x3D; 1;
            n -&#x3D; number_per_level;
            number_per_level *&#x3D; 2;
        &#125;

        int max_level_number &#x3D; int(pow(2, max_level - 1));
        int cur_tree_max_level_number &#x3D; max_level_number;
        int index &#x3D; 1;
        for (int level &#x3D; 0; level &lt; max_level; level++) &#123;
            string line1 &#x3D; string(max_level_number * 3 - 1, &#39; &#39;);

            int cur_level_number &#x3D; min(count - int(pow(2, level)) + 1, int(pow(2, level)));
            bool isLeft &#x3D; true;
            for (int index_cur_level &#x3D; 0; index_cur_level &lt; cur_level_number; index++, index_cur_level++) &#123;
                putNumberInLine(data[index], line1, index_cur_level, cur_tree_max_level_number * 3 - 1, isLeft);
                isLeft &#x3D; !isLeft;
            &#125;
            cout &lt;&lt; line1 &lt;&lt; endl;

            if (level &#x3D;&#x3D; max_level - 1)
                break;

            string line2 &#x3D; string(max_level_number * 3 - 1, &#39; &#39;);
            for (int index_cur_level &#x3D; 0; index_cur_level &lt; cur_level_number; index_cur_level++)
                putBranchInLine(line2, index_cur_level, cur_tree_max_level_number * 3 - 1);
            cout &lt;&lt; line2 &lt;&lt; endl;

            cur_tree_max_level_number &#x2F;&#x3D; 2;
        &#125;
    &#125;

private:
    void putNumberInLine(int num, string &amp;line, int index_cur_level, int cur_tree_width, bool isLeft) &#123;

        int sub_tree_width &#x3D; (cur_tree_width - 1) &#x2F; 2;
        int offset &#x3D; index_cur_level * (cur_tree_width + 1) + sub_tree_width;
        assert(offset + 1 &lt; line.size());
        if (num &gt;&#x3D; 10) &#123;
            line[offset + 0] &#x3D; &#39;0&#39; + num &#x2F; 10;
            line[offset + 1] &#x3D; &#39;0&#39; + num % 10;
        &#125; else &#123;
            if (isLeft)
                line[offset + 0] &#x3D; &#39;0&#39; + num;
            else
                line[offset + 1] &#x3D; &#39;0&#39; + num;
        &#125;
    &#125;

    void putBranchInLine(string &amp;line, int index_cur_level, int cur_tree_width) &#123;

        int sub_tree_width &#x3D; (cur_tree_width - 1) &#x2F; 2;
        int sub_sub_tree_width &#x3D; (sub_tree_width - 1) &#x2F; 2;
        int offset_left &#x3D; index_cur_level * (cur_tree_width + 1) + sub_sub_tree_width;
        assert(offset_left + 1 &lt; line.size());
        int offset_right &#x3D; index_cur_level * (cur_tree_width + 1) + sub_tree_width + 1 + sub_sub_tree_width;
        assert(offset_right &lt; line.size());

        line[offset_left + 1] &#x3D; &#39;&#x2F;&#39;;
        line[offset_right + 0] &#x3D; &#39;\\&#39;;
    &#125;
&#125;;
void testHeapSort() &#123;
    MaxHeap&lt;int&gt; maxHeap &#x3D; MaxHeap&lt;int&gt;(100);
    cout &lt;&lt; maxHeap.size() &lt;&lt; endl;
    int n &#x3D; 15;
    srand(time(NULL));
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        maxHeap.insert(rand() % 100);&#x2F;&#x2F;[0,100)
    &#125;
    maxHeap.print();
    maxHeap.testPrint();

	&#x2F;&#x2F;while (!maxHeap.isEmpty())
    &#x2F;&#x2F;将maxHeap中的数据通过extractMax取出来，
    &#x2F;&#x2F;取出来的数据应该是从大到小顺序取出来的
    int *array &#x3D; new int[n];
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        array[i] &#x3D; maxHeap.extractMax();
        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
    for (int i &#x3D; 1; i &lt; n; i++) &#123;
        assert(array[i - 1] &gt;&#x3D; array[i]);
    &#125;
    delete[] array;
&#125;
int main()&#123;
	testHeapSort();
	std::cout&lt;&lt;&quot;Hello&quot;&lt;&lt;endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/data-structure/">
                                    <span class="chip bg-color">data structure</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/03/%E5%89%91%E6%8C%87offer/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="剑指offer">
                        
                        <span class="card-title">剑指offer</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            coding coding coding
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            moseairius
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%91%E6%8C%87offer/">
                        <span class="chip bg-color">剑指offer</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/10/06/Makefile/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="Makefile">
                        
                        <span class="card-title">Makefile</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Makefile
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-10-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            moseairius
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('3'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">moseairius</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "3";
                    var startDate = "14";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="/null" target="_blank">桂ICP备2021002249号-1</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/Moseasirius" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:zhenhaimo@foxmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
